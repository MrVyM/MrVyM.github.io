"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[3518],{4369:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"pinsyscall-on-openbsd","metadata":{"permalink":"/pinsyscall-on-openbsd","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2025-05-03-Desactiver-pinsyscall-bsd.md","source":"@site/blog/2025-05-03-Desactiver-pinsyscall-bsd.md","title":"D\xe9sactiver les pinsyscalls sur OpenBSD","description":"Les versions r\xe9centes d\'OpenBSD emp\xeachent l\'utilisation directe des syscalls depuis le code utilisateur, en imposant une v\xe9rification dans le linker (ld.so).","date":"2025-05-03T00:00:00.000Z","tags":[{"inline":true,"label":"openbsd","permalink":"/tags/openbsd"},{"inline":true,"label":"syscall","permalink":"/tags/syscall"},{"inline":true,"label":"pinsyscall","permalink":"/tags/pinsyscall"},{"inline":true,"label":"kernel","permalink":"/tags/kernel"}],"readingTime":3.36,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"pinsyscall-on-openbsd","title":"D\xe9sactiver les pinsyscalls sur OpenBSD","tags":["openbsd","syscall","pinsyscall","kernel"],"authors":"mrvym","hide_title":false,"date":"05/03/2025"},"unlisted":false,"nextItem":{"title":"How copy-paste works on Linux ?","permalink":"/how-copy-paste-works-on-linux"}},"content":"Les versions r\xe9centes d\'OpenBSD emp\xeachent l\'utilisation directe des syscalls depuis le code utilisateur, en imposant une v\xe9rification dans le linker (`ld.so`). \\nCela renforce la s\xe9curit\xe9 en rendant les exploits plus difficiles. Cet article explore la mise en place de cette protection, son fonctionnement, et comment la d\xe9sactiver en modifiant le code source du kernel.\\n\x3c!-- truncate --\x3e \\n\\n## Pinsyscalls ? \\n\\nAvant de voir comment d\xe9sactiver un pinsyscalls, cela peut \xeatre int\xe9ressant de voir ce que cela signifie. \\nLe kernel OpenBSD a mise en place une s\xe9curit\xe9 particuli\xe8re sur ces syscalls. Cela a pour but de faire en sorte qu\'un syscall ne puisse \xeatre call que dans une certaine plage d\'addresse dans un binaire. \\n\\nCette s\xe9curit\xe9 veut dire que l\'on ne peut pas ex\xe9cuter un syscall \xe0 la main (cf [Coder le sycall](#coder-le-syscall)).\\n\\n## Trouver le num d\'un syscall \\n\\nAvant tout, nous devons faire un test en appelant un syscall. \\nPour trouver le num\xe9ro de syscall de `void exit(int num)`, nous allons lire le man.\\n```sh\\n$ man 9 syscall\\n```\\nSection `Code references` on trouve /sys/kern/syscall.master\\n\\nCe fichier est tr\xe8s important, il contient la liste des syscalls sur OpenBSD. \xc0 noter qu\'\xe0 la diff\xe9rence de Linux, leurs d\xe9clarations sont faites dans ce fichier donc dynamique. \\nCela fait un des grandes forces de BSD, c\'est relativement \\"simple\\" d\'ajouter un syscall.\\n\\n\\n## Coder le syscall\\n\\n### En ASM\\n```asm\\n.global main\\n.section .text\\n\\nmain:\\n  movl $1, %eax;\\n  syscall;\\n  ret;\\n```\\n\\n### En C \\n\\n```c\\nint main(void) {\\n  asm volatile (\\"movl $1, %eax;\\"\\n                \\"syscall;\\");\\n  return 0; // Unreached code \\n}\\n```\\n\\n## Result \\nOn remarque assez vite que le binaire que nous avons compil\xe9, ne fonctionne pas. \\n`main[10291]: pinsyscalls addr 5a288eab978 code 1, pinoff 0xffffffff (pin 330 5a4c881d000-5a4c882b66d e66d) (libcpin 331 5a5145d0000-5a514687000 b7000) error 78\\nAbort trap (core dumped)`\\n\\nJe suppose que cela doit venir d\'un process interne au kernel, qui check la validit\xe9 de notre appel et qui nous SIGABRT.\\n\\n## Comment fix le syscall ? \\n\\nL\'id\xe9e est de trouver l\'endroit qui check le linkage des syscalls dans le kernel et bypass le `if`.\\n\\nDans un premier temps, on cherche dans les `man` et non pas dans le code.\\n5 min de lecture peuvent nous \xe9viter beaucoup de recherche dans une codebase.\\n\\n```sh\\n$ apropos syscall\\npinsyscalls(2) - pin system call entry to precise locations in the address space\\nsqlite3_vfs, sqlite3_syscall_ptr(3) - OS interface object\\nktrace, ktrgenio, ktrnamei, KTRPOINT, ktrpsig, ktrsyscall, ktrsysret(9) - process tracing kernel interface\\nsyscall(9) - system calls overview\\n```\\nNous avons d\xe9j\xe0 lu le syscall(9) pour trouver notre num\xe9ro de syscall, mais pas encore le premier pinsyscalls(2)\\n\\n### pinsyscalls(2)\\n\\nOn apprend que : \\n- ld.so(1) cree des entry point pour chaque syscalls\\n- si on ne respecte pas les entry point alors SIGABRT \\n- Ca correspond a notre erreur\\n\\n### Trouver pinsyscall\\n\\nJ\'en d\xe9duis que l\'on cherche ou est `pinsyscall(1)`, trouver le code qui l\'appelle puis le fix.\\n\\n```sh \\n$ cd /usr/src\\n# Un peu de recherche sur le mode clef syscall plus tard\\n$ grep -r \\"PINSYSCALL\\"\\n#  ...\\nlib/libc/arch/amd64/SYS.h:\\tPINSYSCALL(SYS_ ## x, 97b)\\n```\\n\\nAlors la macro pinsyscall n\'est pas d\xe9fini dans ce fichier (qui est machine-depend). En regardant les include du header, on voit \\n\\n```c\\n#include \\"DEFS.h\\" // Machine independent\\n#include  // Machine // independent\\n```\\n\\n### Trouver l\'utilisation du pinsyscall\\n\\nJe d\xe9couvre que la fonction `pinsyscall(1)` est d\xe9fini dans mon fichier `DEFS.h`. C\'est une macro qui g\xe9n\xe8re de l\'assembleur. \\nJe ne me lance pas dans l\'analyse de son code pour le moment, n\xe9anmoins, je garde en t\xeate son existence. \\nPour le moment, je cherche le code qui check le fonctionnement du `pinsyscall`. \\n\\nJ\'ai vu que le include  existe, je vais aller voir par la.\\n\\n### sys/syscall.h\\n\\n```c\\n$ find . -name \\"syscall.h\\"\\n./libexec/ld.so/syscall.h\\n./sys/arch/riscv64/include/syscall.h\\n./sys/sys/syscall.h\\n```\\n\\nDeux fichiers ont l\'air int\xe9ressant celui de ld.so (cf le man que l\'on a lu sur les pinsyscall).\\n\\n#### Le dossier libexec/ld.so\\n\\nApr\xe8s un rapide grep dans le directory du syscall.h pour trouver qui l\'utilise. Je trouve le fichier `resolve.c`.\\nCela me permet de d\xe9couvrir l\'impl\xe9mentation de la fonction `pinsyscall` et de la struct.\\n```c title=\\"/usr/src/libexec/ld.so/resolve.c \\"\\n# line 782\\nstruct pinsyscalls {\\n  u_int offset;\\n  u_int sysno;\\n}\\n```\\n#### Le dossier sys/sys\\n\\n```sh\\ngrep -r \\"syscall.h\\"\\nsyscall.h:/*\\t$OpenBSD: syscall.h,v 1.282 2025/02/17 13:10:56 mpi Exp $\\t*/\\nsyscall_mi.h:#include \\n```\\n\\n### The patch\\n\\nNous avons enfin trouv\xe9 le fichier qui contient le fameux `if` qui v\xe9rifie la condition d\'appels des syscalls.\\nIl nous suffit maintenant de supprimer le `else` pour ne jamais set le variable `error`.\\n\\n```diff\\n$ diff syscall_mi.h.patch syscall_mi.h -Naur > syscall.patch\\n--- syscall_mi.h\\t2025-02-20 14:13:12.237060577 +0100\\n+++ syscall_mi.h.patch\\t2025-02-20 14:17:23.279746175 +0100\\n@@ -94,8 +94,7 @@\\n; /* multiple locations, hopefully a boring operation */\\nelse\\nerror = ENOSYS;\\n-\\t} else\\n-\\t\\terror = ENOSYS;\\n+\\t}\\nif (error == 0)\\nreturn (0);\\ndie:\\n```"},{"id":"how-copy-paste-works-on-linux","metadata":{"permalink":"/how-copy-paste-works-on-linux","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2025-01-31-How-copy-paste-works.mdx","source":"@site/blog/2025-01-31-How-copy-paste-works.mdx","title":"How copy-paste works on Linux ?","description":"In this article, we will explore the internal workings of copy and paste in Linux.","date":"2025-04-04T00:00:00.000Z","tags":[{"inline":true,"label":"Linux","permalink":"/tags/linux"},{"inline":true,"label":"Xorg","permalink":"/tags/xorg"},{"inline":true,"label":"Copy","permalink":"/tags/copy"},{"inline":true,"label":"Paste","permalink":"/tags/paste"}],"readingTime":2.4266666666666663,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"how-copy-paste-works-on-linux","title":"How copy-paste works on Linux ?","tags":["Linux","Xorg","Copy","Paste"],"date":"2025-04-04T00:00:00.000Z","authors":["mrvym"]},"unlisted":false,"prevItem":{"title":"D\xe9sactiver les pinsyscalls sur OpenBSD","permalink":"/pinsyscall-on-openbsd"},"nextItem":{"title":"Le plus petit segfault","permalink":"/le-plus-petit-segfault"}},"content":"In this article, we will explore the internal workings of copy and paste in Linux. \\nFirst, let me provide some context. There is a manual, almost like an RFC. \\n\\nThe Inter-Communication Client Conventions Manual (ICCCM for short), which lays down some rules. \\nThe first version was published in July 1989, the second in 1994. \\nThis manual, written 30 years ago, is therefore the reference for the subject.  \\n\\n\x3c!-- truncate --\x3e \\n## First some history \\n### X vs X.org vs X11 \\nThe X Window System, also known as X, is old. Written in 1984, it was the default windowing system for most Unix systems.\\nBut X is not the implementation, it is more a set of protocols and architecture.\\n\\nX.org is the free and open source implementation of the X Window System. X.org is also a foundation that oversees the development of X11.\\n\\nX11 is the latest version (since 1987) of the X architecture, and X10 is the first iteration of the project born with X in 1984.\\n\\n## X10 and cut-buffers\\nFor context, the first release of X10 was in 1985. At that time, the ICCCM hadn\'t been released.\\nXorg was doing its own thing. They used a thing called `cut-buffer\' or also known as `buffer-cut\'.\\n\\nA cut-buffer works like a circular buffer of 8 buffers, ranging from CUTBUFFER0 to CUTBUFFER7.\\nWhen a user tries to add a string to a cut buffer, each string is swapped to a different buffer. \\nSo the circular buffer is like a history of all copy-paste.\\n\\nNowadays, there are no more programs that use a cut-buffer, or at least they used the cut-buffer and the new method.\\n\\n## X11 support \\nX has an object called \'selections\'. It is basically a clipboard, but for a different use.\\nThere are THREE selections defined by ICCCM: Primary, Secondary, and Clipboard The ICCCM also makes a distinction between `Passive` and `Active` selections.\\n\\nPassive\\n> When some data is selected, the client handling the window where this selection is done transfers it somewhere, and no longer needs to care about it\\n\\nActive\\n> Transfer of data to a client requires the client \\"holding\\" the selection to actively participate in the exchange.\\n\\n#### PRIMARY \\nI is mostly used when you select some text with your mouse. You can use your mouse middle click to paste it. \\nI said \\"mostly\\" because it depends on the software. Each X11 application decides which binding it uses to interact with a selection.\\n\\nSo, as you understand, it\'s a `passive\' selection. The user does not ask the system to copy this text. \\n\\n#### CLIPBOARD \\nThis is an `active` selection. It\'s used when the user wants to copy some data. It can be done with either `Ctrl-C` or the simpler `Mouse right click + copy`.\\n\\nIn `vim` you could copy something with `*y` and `*p` or \\n```\\nset clipboard=unnamedplus\\n```\\nSo when the user requests `Paste`, it will be the contents of the CLIPBOARD selection.\\n#### SECONDARY \\nTo be honest, I looked for as much information as I could about this selection, but I couldn\'t find any application that used it for any good reason.\\n\\nIn `vim` you could copy something in it with `+y` and `+p`.\\n```\\nset clipboard=unnamed\\n```\\n\\n## XDND \\nSuch a complex word, it\'s just the first letter of `X Drag and Drop Protocol`. When I did some research on the clipboard, I found information about drag and drop. \\n\\nWhen a drag starts, the source takes ownership of `XDNDSelection` (a structure inside X11), and when the mouse leaves the source, X11 sends a message to the target. At this point the user can release the mouse, the target gets a lot of information with a specific selection `XA_PRIMARY`. XA stands for XDNDAware, the module responsible for DND in X. With all this information, the target software could easily request the resource from the source software. \\nI learn that within the first iteration of X, there are no optimizations when `target = source\'.\\n\\n## Alias\\n\\n```bash\\nalias paste=\\"xclip -o\\"\\n\\nalias copy=\\"xclip\\"\\n```\\n\\nAnd so you can use like this.\\n\\n```bash\\ncat LONG_FILE | copy \\n\\npaste | vim - \\n```\\nSources : \\n- [ICCCM](https://x.org/releases/X11R7.6/doc/xorg-docs/specs/ICCCM/icccm.html)\\n- [VimDoc](http://vimdoc.sourceforge.net/htmldoc/gui_x11.html#quoteplus)\\n- [ClipbordWiki](https://www.freedesktop.org/wiki/Specifications/ClipboardsWiki/)\\n- [StackOverflow - Diff between X Clip](https://superuser.com/questions/90257/what-is-the-difference-between-the-x-clipboards)\\n- [XDND](https://freedesktop.org/wiki/Specifications/XDND/)"},{"id":"le-plus-petit-segfault","metadata":{"permalink":"/le-plus-petit-segfault","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2025-01-17-petit-segfault/index.md","source":"@site/blog/2025-01-17-petit-segfault/index.md","title":"Le plus petit segfault","description":"Coder le plus petit segfault du monde ! Et creusez dans le fonctionnement du \'main\'.","date":"2025-01-17T00:00:00.000Z","tags":[{"inline":false,"label":"C Language","permalink":"/tags/c","description":"The most wonderful language"},{"inline":true,"label":"segv","permalink":"/tags/segv"}],"readingTime":7.619999999999999,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"le-plus-petit-segfault","title":"Le plus petit segfault","description":"Coder le plus petit segfault du monde ! Et creusez dans le fonctionnement du \'main\'.","tags":["C","segv"],"hide_title":false,"authors":["mrvym"]},"unlisted":false,"prevItem":{"title":"How copy-paste works on Linux ?","permalink":"/how-copy-paste-works-on-linux"},"nextItem":{"title":"Tester c\'est tricher, compiler c\'est douter","permalink":"/tester-cest-tricher-compiler-c-est-douter"}},"content":"Dans cet article, on va voir comment cr\xe9er un code qui crash le plus efficacement possible.  \\nCela veut dire comprendre ce qu\'est un segfault, comment marche la fonction `main`, ainsi que le code ex\xe9cut\xe9 avant.\\n\\nUne magnifique occasion de faire de l\'assembleur !\\n\\n\x3c!-- truncate --\x3e \\n### Sans plus attendre, voici notre premier exemple :\\n\\n```c\\nmain;\\n```\\n\\nCe code compile tr\xe8s bien :  \\n> `gcc main.c -o main`\\n\\net produit cet output :\\n\\n```sh\\n$ ./main\\n[1]    20677 segmentation fault (core dumped)  ./main\\n```\\n\\n\\n### Un segfault\\n\\nJe pense que c\u2019est le bon moment pour r\xe9pondre \xe0 cette question : c\u2019est quoi un segfault ?  \\n\\nUn **segfault** ou \\"segmentation fault\\" est une erreur de segmentation. On l\u2019obtient lorsque notre programme essaye de lire un pointeur qui ne nous appartient pas.  \\nAu lancement du programme, l\u2019OS lui attribue une certaine quantit\xe9 de m\xe9moire, et il n\u2019a pas le droit d\u2019en sortir.\\n\\nC\u2019est une s\xe9curit\xe9 pour emp\xeacher des programmes d\u2019acc\xe9der \xe0 des zones m\xe9moire non autoris\xe9es.\\n\\nQuand l\u2019OS (ou plus pr\xe9cis\xe9ment, le MMU) d\xe9tecte que le programme tente d\u2019acc\xe9der \xe0 une m\xe9moire non autoris\xe9e, il g\xe9n\xe8re cette \\"fault\\".\\n\\n\\n### On dump des objets\\n\\nPour mieux comprendre le fonctionnement du programme, on va aller voir le code machine.  \\nLe flag `-t` nous permet de r\xe9cup\xe9rer juste la liste des symboles :  \\n\\n```sh\\n$ objdump -t ./main\\n# <-- truncate --\x3e \\n0000000000004000  w      .data\\t0000000000000000              data_start\\n0000000000004000 g       .data\\t0000000000000000              __data_start\\n0000000000001020 g     F .text\\t0000000000000026              _start\\n0000000000004010 g       .bss\\t0000000000000000              __bss_start\\n0000000000004014 g     O .bss\\t0000000000000004              main\\n# <-- truncate --\x3e \\n0000000000001000 g     F .init\\t0000000000000000              .hidden _init\\n```\\n\\nOn remarque que le symbole `main` est dans le segment `.bss` et pas dans `.text`.\\n\\n![Segments in ELF file](./segment-c-code.png)\\n\\n#### Segment **bss** :  \\n> Le segment `.bss` (Block Starting Symbol) contient les variables statiques allou\xe9es.  \\n\\n#### Segment **text** :  \\n> Le segment `.text` contient les instructions ex\xe9cutables du programme.\\n\\n\\nOn se rend compte que notre code ne d\xe9clare pas une fonction, mais bien une variable. La variable \xe9tant globale, le compilateur cr\xe9e un symbole pour elle.  \\nCela se v\xe9rifie tr\xe8s simplement en rajoutant une variable `test` dans notre code :  \\n\\n```sh\\n0000000000004018 g     O .bss\\t0000000000000004              test\\n```\\n\\nEn effet, le nom `main` n\u2019est pas un keyword sp\xe9cifique en C. C\u2019est juste un nom de fonction arbitraire qui est appel\xe9 au lancement du programme.\\n\\n\\n### Pour les Qu\xe9b\xe9cois\\n\\nPour les puristes d\u2019entre vous, il est tout \xe0 fait possible de ne pas inclure une fonction `main` dans votre code.  \\nIl suffit d\u2019\xe9crire votre propre fonction `_start` et de demander \xe0 GCC de ne pas linker la sienne :\\n\\n```c\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint principale() {\\n  puts(\\"Hey l\xe0, \xe7a marche-tu?\\");\\n  return 0;\\n}\\n\\nvoid _start() {\\n  int ret = principale();\\n  exit(ret);\\n}\\n```\\n\\n> `$ gcc principale.c -o principale -nostartfiles`\\n\\n\\n### Lancement du programme\\n\\nMais au fait, qui call la fonction `main` ?\\n\\nPour r\xe9pondre \xe0 cette question, regardons le code assembleur de notre programme, en particulier la fonction `_start`.  \\nAu passage, on remarque que son symbole est bien dans le segment `.text`.\\n\\nVoici une version simplifi\xe9e du code (la fonction compl\xe8te est assez complexe) :\\n\\n```nasm\\n_start: \\n    xor %ebp, %ebp            \\n    mov (%rsp), %edi          \\n    lea 8(%rsp), %rsi         \\n    lea 16(%rsp,%rdi,8), %rdx \\n    xor %eax, %eax            \\n    call main                 \\n\\n    mov %eax, %edi    \\n    xor %eax, %eax   \\n    call _exit      \\n```\\n\\n#### \xc9tapes de `_start` :\\n- On marque la fin de la stack frame :  \\n    `xor %ebp, %ebp`  \\n- On initialise `argc` :  \\n    `mov (%rsp), %edi`  \\n- On initialise `argv` :  \\n    `lea 8(%rsp), %rsi`  \\n- On initialise `envp` :  \\n    `lea 16(%rsp,%rdi,8), %rdx`  \\n- On set un code retour initialis\xe9 \xe0 0 (compatibilit\xe9) :  \\n    `xor %eax, %eax`  \\n- On call `main(argc, argv, envp)` :  \\n    `call main`  \\n- On call la fonction `_exit` avec le code retour :  \\n    `mov %eax, %edi`  \\n    `call _exit`\\n\\n### Envp ??\\n\\nLe vrai prototype de la fonction `main` a 3 arguments :  \\n\\n```c\\nint main(int argc, char* argv[], char* envp[]);\\n```\\n\\n> Oui, j\u2019ai d\xe9couvert le vrai prototype en analysant le reverse de `_start`.\\n\\nComme son nom l\u2019indique, `envp` correspond aux variables d\u2019environnement du shell.  \\nSi on ne vous a jamais montr\xe9 \xe7a, c\u2019est parce que ce n\u2019est pas portable (m\xeame si toutes les machines actuelles le supportent).\\n\\n\\n### Encore plus petit\\n\\nEt oui, si vous avez bien suivi, il est maintenant possible de segfault encore plus vite. Il suffit que le segfault soit directement dans la fonction `_start`, sans passer par `main`.  \\n\\nVoici un exemple minimaliste (vide) :  \\n\\n```sh\\n$ touch main.c\\n/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000001000\\n$ gcc -o main main.c -nostartfiles\\n```\\n\\nNous avons certes un warning, mais \xe7a compile.  \\nUn `objdump` montre qu\u2019il n\u2019y a presque rien dans ce fichier et que le symbole `_start` n\u2019est pas d\xe9fini :\\n\\n```sh\\n$ objdump -t ./main\\n<-- truncate --\x3e \\n0000000000000000         *UND*\\t0000000000000000 _start\\n```\\n## Scrt1.o, \xe7a sort d\'o\xf9 ?\\n\\nAlors hormis le fait que j\'ai lu la doc de GCC, comment est-ce que je sais que `Scrt1.o` existe ?  \\nVous connaissez le `-v` ? Eh oui, on peut tr\xe8s bien activer le debug / verbose sur GCC.  \\n\\nPersonne ne le fait parce qu\'il faut avoir un sacr\xe9 melon pour consid\xe9rer que GCC fait mal son travail (sauf moi).  \\n\\nEn activant ce flag, on se retrouve avec pas mal de variables d\'env qui sont print, mais pas que. On trouve notamment cette ligne dans laquelle on voit l\'include des fichiers `.o` :  \\n\\n```sh\\n/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/collect2 \\n    -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/liblto_plugin.so \\n    -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/lto-wrapper \\n    -plugin-opt=-fresolution=/tmp/ccEcycpv.res \\n    -plugin-opt=-pass-through=-lgcc \\n    -plugin-opt=-pass-through=-lgcc_s \\n    -plugin-opt=-pass-through=-lc \\n    -plugin-opt=-pass-through=-lgcc \\n    -plugin-opt=-pass-through=-lgcc_s \\n    --build-id --eh-frame-hdr --hash-style=gnu \\n    -m elf_x86_64 \\n    -dynamic-linker /lib64/ld-linux-x86-64.so.2 \\n    -pie -o main \\n    /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/Scrt1.o \\n    /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/crti.o \\n    /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/crtbeginS.o \\n    -L/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1 \\n    -L/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib -L/lib/../lib -L/usr/lib/../lib \\n    -L/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../.. /tmp/cciOyF1Z.o \\n    -lgcc \\n    --push-state \\n    --as-needed \\n    -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s \\n    --pop-state /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/crtendS.o \\n    /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/crtn.o\\n```\\n\\nOn remarque beaucoup de flags, on peut essayer d\'analyser rapidement leur effet.  \\n\\n- Les amateurs de CTF, vous aurez remarqu\xe9 le flag `-pie`, qui permet d\'activer l\'Address Space Layout Randomization (ASLR).  \\n- `-lgcc` : eh oui, votre programme C compile avec la librairie dynamique GCC.  \\n  Vous pouvez \xe9viter \xe7a en compilant avec `-nostdlib`. Je ne vois pas bien l\'int\xe9r\xeat, mais c\'est un choix.  \\n- `-m elf_x86_64` : c\'est ici que GCC sp\xe9cifie l\'architecture de la machine cible.  \\n  C\'est possible de modifier cette machine cible, cela s\'appelle la cross compilation (mais j\'en ferai un article sp\xe9cifique).  \\n\\nOn trouve aussi le fichier `Scrt1.o`, qui contient le point d\'entr\xe9e (`_start`) de l\'ex\xe9cutable. Les fichiers `crti.o` et `crtbeginS.o`, eux, fournissent des routines n\xe9cessaires \xe0 l\u2019initialisation des fonctions globales et statiques.  \\nOn pourra citer les fonctions `_init` et `_fini`.  \\n\\n\\nSource : \\n- [The C Runtime Initialization, crt0.o](https://www.embecosm.com/appnotes/ean9/html/ch05s02.html)\\n- [Linux Questions - Forums](https://www.linuxquestions.org/questions/programming-9/_start-_init-and-frame_dummy-functions-810257/)\\n- [Stackoverflow - _start in C](https://stackoverflow.com/questions/29694564/what-is-the-use-of-start-in-c)\\n\\n### Bonus\\n\\nPour les **chads** ! Voici le code complet de la fonction `_start`.\\n\\n<details>\\n```asm\\n0000000000001020 <_start>:\\n    1020:\\tf3 0f 1e fa          \\tendbr64\\n    1024:\\t31 ed                \\txor    %ebp,%ebp\\n    1026:\\t49 89 d1             \\tmov    %rdx,%r9\\n    1029:\\t5e                   \\tpop    %rsi\\n    102a:\\t48 89 e2             \\tmov    %rsp,%rdx\\n    102d:\\t48 83 e4 f0          \\tand    $0xfffffffffffffff0,%rsp\\n    1031:\\t50                   \\tpush   %rax\\n    1032:\\t54                   \\tpush   %rsp\\n    1033:\\t45 31 c0             \\txor    %r8d,%r8d\\n    1036:\\t31 c9                \\txor    %ecx,%ecx\\n    1038:\\t48 8d 3d d5 2f 00 00 \\tlea    0x2fd5(%rip),%rdi        # 4014 <main>\\n    103f:\\tff 15 7b 2f 00 00    \\tcall   *0x2f7b(%rip)        # 3fc0 <__libc_start_main@GLIBC_2.34>\\n    1045:\\tf4                   \\thlt\\n    1046:\\t66 2e 0f 1f 84 00 00 \\tcs nopw 0x0(%rax,%rax,1)\\n    104d:\\t00 00 00\\n    1050:\\t48 8d 3d b9 2f 00 00 \\tlea    0x2fb9(%rip),%rdi        # 4010 <__TMC_END__>\\n    1057:\\t48 8d 05 b2 2f 00 00 \\tlea    0x2fb2(%rip),%rax        # 4010 <__TMC_END__>\\n    105e:\\t48 39 f8             \\tcmp    %rdi,%rax\\n    1061:\\t74 15                \\tje     1078 <_start+0x58>\\n    1063:\\t48 8b 05 5e 2f 00 00 \\tmov    0x2f5e(%rip),%rax        # 3fc8 <_ITM_deregisterTMCloneTable@Base>\\n    106a:\\t48 85 c0             \\ttest   %rax,%rax\\n    106d:\\t74 09                \\tje     1078 <_start+0x58>\\n    106f:\\tff e0                \\tjmp    *%rax\\n    1071:\\t0f 1f 80 00 00 00 00 \\tnopl   0x0(%rax)\\n    1078:\\tc3                   \\tret\\n    1079:\\t0f 1f 80 00 00 00 00 \\tnopl   0x0(%rax)\\n    1080:\\t48 8d 3d 89 2f 00 00 \\tlea    0x2f89(%rip),%rdi        # 4010 <__TMC_END__>\\n    1087:\\t48 8d 35 82 2f 00 00 \\tlea    0x2f82(%rip),%rsi        # 4010 <__TMC_END__>\\n    108e:\\t48 29 fe             \\tsub    %rdi,%rsi\\n    1091:\\t48 89 f0             \\tmov    %rsi,%rax\\n    1094:\\t48 c1 ee 3f          \\tshr    $0x3f,%rsi\\n    1098:\\t48 c1 f8 03          \\tsar    $0x3,%rax\\n    109c:\\t48 01 c6             \\tadd    %rax,%rsi\\n    109f:\\t48 d1 fe             \\tsar    $1,%rsi\\n    10a2:\\t74 14                \\tje     10b8 <_start+0x98>\\n    10a4:\\t48 8b 05 2d 2f 00 00 \\tmov    0x2f2d(%rip),%rax        # 3fd8 <_ITM_registerTMCloneTable@Base>\\n    10ab:\\t48 85 c0             \\ttest   %rax,%rax\\n    10ae:\\t74 08                \\tje     10b8 <_start+0x98>\\n    10b0:\\tff e0                \\tjmp    *%rax\\n    10b2:\\t66 0f 1f 44 00 00    \\tnopw   0x0(%rax,%rax,1)\\n    10b8:\\tc3                   \\tret\\n    10b9:\\t0f 1f 80 00 00 00 00 \\tnopl   0x0(%rax)\\n    10c0:\\tf3 0f 1e fa          \\tendbr64\\n    10c4:\\t80 3d 45 2f 00 00 00 \\tcmpb   $0x0,0x2f45(%rip)        # 4010 <__TMC_END__>\\n    10cb:\\t75 33                \\tjne    1100 <_start+0xe0>\\n    10cd:\\t55                   \\tpush   %rbp\\n    10ce:\\t48 83 3d 0a 2f 00 00 \\tcmpq   $0x0,0x2f0a(%rip)        # 3fe0 <__cxa_finalize@GLIBC_2.2.5>\\n    10d5:\\t00\\n    10d6:\\t48 89 e5             \\tmov    %rsp,%rbp\\n    10d9:\\t74 0d                \\tje     10e8 <_start+0xc8>\\n    10db:\\t48 8b 3d 26 2f 00 00 \\tmov    0x2f26(%rip),%rdi        # 4008 <__dso_handle>\\n    10e2:\\tff 15 f8 2e 00 00    \\tcall   *0x2ef8(%rip)        # 3fe0 <__cxa_finalize@GLIBC_2.2.5>\\n    10e8:\\te8 63 ff ff ff       \\tcall   1050 <_start+0x30>\\n    10ed:\\tc6 05 1c 2f 00 00 01 \\tmovb   $0x1,0x2f1c(%rip)        # 4010 <__TMC_END__>\\n    10f4:\\t5d                   \\tpop    %rbp\\n    10f5:\\tc3                   \\tret\\n    10f6:\\t66 2e 0f 1f 84 00 00 \\tcs nopw 0x0(%rax,%rax,1)\\n    10fd:\\t00 00 00\\n    1100:\\tc3                   \\tret\\n    1101:\\t66 66 2e 0f 1f 84 00 \\tdata16 cs nopw 0x0(%rax,%rax,1)\\n    1108:\\t00 00 00 00\\n    110c:\\t0f 1f 40 00          \\tnopl   0x0(%rax)\\n    1110:\\tf3 0f 1e fa          \\tendbr64\\n    1114:\\te9 67 ff ff ff       \\tjmp    1080 <_start+0x60>\\n```\\n</details>"},{"id":"tester-cest-tricher-compiler-c-est-douter","metadata":{"permalink":"/tester-cest-tricher-compiler-c-est-douter","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2025-01-10-Tester-cest-tricher/index.md","source":"@site/blog/2025-01-10-Tester-cest-tricher/index.md","title":"Tester c\'est tricher, compiler c\'est douter","description":"Dans cet article, nous allons voir le concept de Continuous Integration (CI), son int\xe9r\xeat et ses inconv\xe9nients et une d\xe9monstration.","date":"2025-01-10T00:00:00.000Z","tags":[{"inline":true,"label":"git","permalink":"/tags/git"},{"inline":true,"label":"CI","permalink":"/tags/ci"},{"inline":false,"label":"C Language","permalink":"/tags/c","description":"The most wonderful language"}],"readingTime":3.786666666666666,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"title":"Tester c\'est tricher, compiler c\'est douter","slug":"tester-cest-tricher-compiler-c-est-douter","tags":["git","CI","C"],"hide_title":false,"date":"2025-01-10T00:00:00.000Z","authors":["mrvym"]},"unlisted":false,"prevItem":{"title":"Le plus petit segfault","permalink":"/le-plus-petit-segfault"},"nextItem":{"title":"Introduction \xe0 Terraform avec Proxmox","permalink":"/intro-terraform-proxmox"}},"content":"Dans cet article, nous allons voir le concept de Continuous Integration (CI), son int\xe9r\xeat et ses inconv\xe9nients et une d\xe9monstration.\\n\\n## Histoire\\n\\nMais d\'abord, comme \xe0 mon habitude, un petit point histoire.\\n\\n> En 1999, Kent Beck a approfondi le sujet dans son premier livre sur l\'Extreme Programming. En 2001, CruiseControl, l\'un des premiers outils open-source de CI, a vu le jour.\\n\x3c!-- truncate --\x3e \\n## Mais why ?  \\nLe but d\'une CI est de faire des tests automatis\xe9s \xe0 chaque commit. Cela garantit que le code reste fonctionnel en permanence. On appelle cela une Continuous Integration car, \xe0 chaque modification, le code est v\xe9rifi\xe9 pour s\'assurer qu\'il n\'y a pas de r\xe9gressions.\\n\\n### Avantages\\n\\n- **D\xe9tection pr\xe9coce des erreurs** : Les probl\xe8mes sont identifi\xe9s rapidement, ce qui permet de r\xe9agir sans attendre.  \\n- **Am\xe9lioration de la qualit\xe9** : En testant syst\xe9matiquement, on garantit un code plus robuste.  \\n- **Gain de temps** : Les pipelines automatis\xe9s r\xe9duisent la n\xe9cessit\xe9 de tests manuels r\xe9p\xe9titifs.\\n\\n### Inconv\xe9nients\\n\\n- **Co\xfbt initial** : Mettre en place une CI peut demander des efforts et des comp\xe9tences initiales importantes.  \\n- **Temps d\u2019ex\xe9cution** : Les pipelines complexes peuvent rallonger le temps avant qu\'un d\xe9veloppeur puisse valider son code.\\n\\n## Fonctionnement\\n\\nAvant de voir le fonctionnement, un petit lexique :  \\n\\n- **Jobs** : Une instance d\'un conteneur (souvent Docker) qui ex\xe9cute un script. Cela peut inclure des commandes, des tests ou des actions simples comme un `echo`.  \\n- **Pipeline** : Une s\xe9rie de jobs organis\xe9s de mani\xe8re s\xe9quentielle ou parall\xe8le. Chaque commit d\xe9clenche cette s\xe9rie pour valider les changements.  \\n\\nLe principe est simple : chaque job retourne un code de statut (succ\xe8s ou \xe9chec). Si un job \xe9choue, la pipeline s\u2019arr\xeate ou ignore les \xe9tapes suivantes selon la configuration.\\n\\n## Tr\xeave de blabla\\n\\nNous allons utiliser un exemple bas\xe9 sur GitLab CI. On la configure via un fichier `.gitlab-ci.yml`.\\n\\n### Basique, simple, simple, basique\\n\\n```yaml\\nimage: bookworm-slim:latest\\n\\nmyjobname:\\n  script:\\n    - make\\n```\\n\\n### Les flags\\n\\nPour ajouter des flags de compilation, deux approches sont possibles :  \\n\\n1. Via une r\xe8gle dans le Makefile.  \\n2. En passant les flags directement dans la commande CI.  \\n\\n```yaml\\nmyjobname_hard:\\n  script:\\n    - CFLAGS=\\"-Wall -Werror\\" make\\n    # ou\\n    - make compile_flags\\n```\\n\\n### Tests avec Criterion et flags\\n\\nCriterion est une biblioth\xe8que de tests unitaires en C.\\n\\n#### O\xf9 est pass\xe9 Criterion ?  \\n\\nAvant d\u2019ex\xe9cuter des tests avec Criterion, il est souvent n\xe9cessaire d\'installer Criterion, eh oui !\\n\\n```yaml\\nbefore_script:\\n  - apt-get update && apt-get install -y libcriterion-dev\\nscript:\\n  - ./configure\\n  - make test\\n```\\n\\n#### Multistaging\\nDiviser les tests unitaires et fonctionnels en plusieurs stages garantit :  \\n- une bonne organisation  \\n- une meilleure visibilit\xe9 des r\xe9sultats  \\n\\n```yaml\\nstages:\\n  - build\\n  - test\\n\\nbuild:\\n  stage: build\\n  script:\\n    - make all\\n\\ntest-unit:\\n  stage: test\\n  script:\\n    - make unit-test\\n\\ntest-functional:\\n  stage: test\\n  script:\\n    - make functional-test\\n```\\n\\n### Tu t\'es fait clang ?  \\n\\nLe formatage du code est super important pour maintenir une base de code propre.  \\n\\n```yaml\\nclang_format:\\n  stage: format\\n  before_script:\\n    - apt-get -qq update && apt-get -qq install -y clang-format autotools-dev autoconf-archive gcovr libcriterion-dev\\n  script:\\n    - clang-format -i $(find src/ -type f -name \\"*.c\\") --dry-run --Werror\\n```\\n\\n### Cache\\n\\nDans certains cas, c\'est utile de mettre en cache des fichiers ou dossiers pour \xe9viter de les recharger \xe0 chaque pipeline.  \\nUn exemple courant est le dossier `node_modules/` en JavaScript.\\n\\n```yaml\\ncache:\\n  paths:\\n    - node_modules/\\n\\ninstall:\\n  script:\\n    - npm install\\n```\\n\\nBien entendu, vous pouvez nettoyer le cache au besoin avec une option suppl\xe9mentaire dans la configuration de pipeline.\\n\\n### Artefacts\\n\\nLes artefacts sont les fichiers g\xe9n\xe9r\xe9s par la CI qui peuvent \xeatre partag\xe9s entre jobs ou t\xe9l\xe9charg\xe9s.  \\nPar exemple, les rapports de tests ou de couverture.\\n\\n```yaml\\nartifacts:\\n  paths:\\n    - build/\\n    - reports/\\n```\\n\\n### Coverage de tests\\n\\nOn peut mesurer la couverture de tests en int\xe9grant des outils comme gcovr ou Cobertura dans votre pipeline CI.\\n\\n```yaml\\ntest-coverage:\\n  stage: test\\n  script:\\n    - gcovr --html --html-details -o coverage.html\\n  artifacts:\\n    paths:\\n      - coverage.html\\n```\\n\\n#### Rapporteur\\n\\nCe bloc vous permet d\'int\xe9grer le coverage report dans votre Merge Request, vous pourrez ainsi voir le code qui n\'est pas couvert mais aussi votre pourcentage de coverage. \\n\\n```yaml\\ncoverage-report:\\n  script:\\n    # do coverage\\n  coverage: /^TOTAL.*\\\\s+(\\\\d+\\\\%)$/\\n  artifacts:\\n    name: coverage.xml\\n    expire_in: 2 days\\n    reports:\\n      coverage_report:\\n        coverage_format: cobertura\\n        path: coverage.xml\\n\\n```\\n### Environnement custom  \\n\\nVous pouvez pr\xe9ciser l\u2019environnement de base pour votre CI en s\xe9lectionnant une image Docker sp\xe9cifique.\\n\\n```yaml\\nimage: gcc:latest\\n```\\n\\nEn utilisant un peu ce que l\'on vient de voir, \xe7a donnerait quelque chose comme \xe7a :  \\n\\n```yaml\\nimage: gcc\\n\\nstages:\\n  - format\\n  - build\\n  - test\\n  - clean\\n\\nclang-format:\\n  stage: format\\n  script:\\n    - clang-format -i $(find src/ -type f -name \\"*.c\\") --dry-run --Werror\\n\\nbuild:\\n  stage: build\\n  script:\\n    - autoreconf --install\\n    - ./configure\\n    - make all\\n\\ntest-unit:\\n  stage: test\\n  script:\\n    - autoreconf --install\\n    - ./configure\\n    - make unit-test\\n```\\n\\n> Attention aux `.h` et il manque des `before_script`.\\n\\n### Petit Bonus  \\n\\nOn peut aussi v\xe9rifier les trash-files pour s\u2019assurer que le `make clean` fait bien son travail.\\n\\n```yaml\\ntrash-file:\\n  stage: clean\\n  needs: []\\n  before_script:\\n    - apt-get -qq update && apt-get -qq install -y tree\\n  script:\\n    - tree > /tmp/REF\\n    - make && make clean\\n    - tree > /tmp/TEST\\n    - diff /tmp/REF /tmp/TEST\\n```\\n\\n## Conclusion\\n\\nLa Continuous Integration est un outil extr\xeamement puissant. Il peut parfois \xeatre difficile \xe0 mettre en place, mais les gains sont immenses."},{"id":"intro-terraform-proxmox","metadata":{"permalink":"/intro-terraform-proxmox","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2024-12-02-intro-terraform-proxmox.md","source":"@site/blog/2024-12-02-intro-terraform-proxmox.md","title":"Introduction \xe0 Terraform avec Proxmox","description":"Le but de Terraform est de d\xe9ployer une infrastructure ou une entit\xe9 de mani\xe8re idempotente. Cela signifie que l\u2019on doit pouvoir relancer le script 100 fois et obtenir le m\xeame r\xe9sultat \xe0 chaque ex\xe9cution.","date":"2024-12-02T00:00:00.000Z","tags":[{"inline":true,"label":"terraform","permalink":"/tags/terraform"},{"inline":true,"label":"proxmox","permalink":"/tags/proxmox"},{"inline":false,"label":"devops","permalink":"/tags/devops","description":"DevOps - Tools"},{"inline":true,"label":"hcl","permalink":"/tags/hcl"},{"inline":true,"label":"BPG","permalink":"/tags/bpg"}],"readingTime":4.826666666666666,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"intro-terraform-proxmox","title":"Introduction \xe0 Terraform avec Proxmox","tags":["terraform","proxmox","devops","hcl","BPG"],"authors":["mrvym"],"hide_title":false,"date":"2024-12-02T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Tester c\'est tricher, compiler c\'est douter","permalink":"/tester-cest-tricher-compiler-c-est-douter"},"nextItem":{"title":"Disque dur : SAS, SATA, SCSI ou IDE ?","permalink":"/disque-dur-sas-sata-scsi-ide"}},"content":"Le but de Terraform est de d\xe9ployer une infrastructure ou une entit\xe9 de mani\xe8re **idempotente**. Cela signifie que l\u2019on doit pouvoir relancer le script 100 fois et obtenir le m\xeame r\xe9sultat \xe0 chaque ex\xe9cution.  \\nPour cela, nous utilisons un **provider**, qui est essentiellement une biblioth\xe8que permettant de se connecter \xe0 notre serveur.\\n\\nDans ce cas pratique, nous allons utiliser **Proxmox** et **BPG**. Il existe deux principaux providers pour Proxmox :\\n\\n- **[Telmate](https://registry.terraform.io/providers/Telmate/proxmox/latest/docs)**  \\n  C\u2019est une biblioth\xe8que qui permet de d\xe9ployer tr\xe8s simplement des VMs et des LXCs.  \\n  Inconv\xe9nient : elle n\u2019impl\xe9mente pas de fonctionnalit\xe9s avanc\xe9es. Cependant, elle est fr\xe9quemment mise \xe0 jour.\\n  \\n- **[Bpg](https://registry.terraform.io/providers/bpg/proxmox/latest/docs)**  \\n  Cette biblioth\xe8que est l\xe9g\xe8rement plus complexe \xe0 prendre en main, mais elle est bien plus puissante.\\n\\n\x3c!-- truncate --\x3e \\n## Organisation et Structure d\'un Projet Terraform \\n\\nAfin que vous puissiez mieux comprendre le projet, voici son architecture\xa0:\\n\\n```sh\\n\u251c\u2500\u2500 main.tf\\n\u251c\u2500\u2500 provider.tf\\n\u251c\u2500\u2500 variable.tf\\n\u2514\u2500\u2500 terraform.auto.tfvars\\n```\\n\\nVous pouvez ajouter ou segmenter le projet en autant de fichiers `.tf` que n\xe9cessaire. Par exemple, nous aurions pu avoir un fichier pour les VMs et un autre pour les LXCs.\\n\\n- Les fichiers se terminant par `.tfvars` servent \xe0 d\xe9finir des variables. Lorsqu\u2019ils commencent par `auto`, ils sont automatiquement charg\xe9s par Terraform.  \\n- Le fichier `variable.tf` permet de cr\xe9er des variables sans les instancier.\\n\\n### Petit point Vocabulaire\\nDans cette article, nous allons utiliser le terme de LXC et de VM. Je vais faire un petit point dessus.\\n\\n- **`LXC`** ou **`LinuX Container`** : ce sont des environnements virtualis\xe9s qui tourne sur le `kernel` de l\'h\xf4te mais qui ne peuvent pas discuter ensemble. Cela permet de segmenter nos services sans trop perde en performance.\\n\\n- **`VM`** ou **`Virtual Machine`** : comme son nom l\'indique, on simule l\'int\xe9gralit\xe9 d\'une machine. On perd en performance mais on gagne en s\xe9curit\xe9 et en fonctionnalit\xe9 car un LXC n\'a pas tout les privil\xe8ges.\\n\\n## Choisir et Configurer un Provider Proxmox\\n\\nAvant tout, nous devons installer le **provider** (la biblioth\xe8que). Bien entendu, nous fixons une version minimale :  \\n\\n```hcl\\nterraform {\\n  required_providers {\\n    proxmox = {\\n      source  = \\"bpg/proxmox\\"\\n      version = \\">= 0.3.0\\"\\n    }\\n  }\\n  required_version = \\">= 0.14\\"\\n}\\n```\\n\\nUne fois la biblioth\xe8que ajout\xe9e, nous d\xe9clarons un provider nomm\xe9 \\"proxmox\\", en fournissant les informations n\xe9cessaires :  \\n\\n```hcl\\nprovider \\"proxmox\\" {\\n  endpoint = \\"https://${var.proxmox_endpoint}:8006\\"\\n  api_token = var.api_token_secret\\n\\n  insecure = true # car un certificat TLS auto-sign\xe9 est utilis\xe9\\n  ssh {\\n    agent = true\\n    username = terraform\\n  }\\n}\\n```\\n\\n---\\n\\n## Les Variables dans Terraform\\n\\nSi vous \xeates attentif, vous avez remarqu\xe9 que nous utilisons l\u2019objet `var.api_token_secret` dans le bloc du provider. Cette cha\xeene de caract\xe8res est d\xe9finie dans le fichier `terraform.auto.tfvars`.  \\n\\n\xc0 la mani\xe8re d\u2019un fichier `.env`, ce fichier contient des valeurs sensibles et **ne doit pas \xeatre pouss\xe9 sur le d\xe9p\xf4t git** :  \\n\\n```hcl\\n# terraform.auto.tfvars\\napi_token_secret = \\"terraform-prov@pve!terraform=TOKEN\\"\\n```\\n\\nDans le fichier `variable.tf`, nous d\xe9finissons les variables et leur type.  \\nVoici les principaux types disponibles :  \\n\\n- **number**\\n- **string**\\n- **list()** (ex. : `list(string)`)\\n- **object**\\n- **map**\\n\\nExemple\xa0:  \\n\\n```hcl\\n# variable.tf\\n\\nvariable \\"api_token_secret\\" {\\n  description = \\"Secret token to connect Proxmox API\\"\\n  type        = string\\n}\\n\\nvariable \\"proxmox_endpoint\\" {\\n  description = \\"The domain name of the Proxmox instance\\"\\n  type        = string\\n  default     = \\"proxmox.mysite.fr\\"\\n}\\n```\\n\\n---\\n\\n## Les Images et les Templates\\n\\nPour d\xe9marrer nos entit\xe9s, nous devons leur fournir un syst\xe8me d\u2019exploitation.  \\nNous t\xe9l\xe9chargeons automatiquement un fichier de template pour le LXC et un ISO avec **cloud-init** pour la VM.  \\n\\n> Si vous ne connaissez pas **cloud-init**, c\u2019est une m\xe9thode permettant d\u2019instancier des machines sans passer par l\u2019installateur de l\u2019OS.  \\n\\n```hcl\\nresource \\"proxmox_virtual_environment_download_file\\" \\"ubuntu_22-04_lxc\\" {\\n  content_type = \\"vztmpl\\"\\n  datastore_id = \\"local\\"\\n  node_name    = var.target_node\\n  url          = \\"http://download.proxmox.com/images/system/ubuntu-22.04-standard_22.04-1_amd64.tar.zst\\"\\n}\\n\\nresource \\"proxmox_virtual_environment_download_file\\" \\"ubuntu_22-04_img\\" {\\n  content_type = \\"iso\\"\\n  datastore_id = \\"local\\"\\n  node_name    = var.target_node\\n  url          = \\"https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img\\"\\n}\\n```\\n\\n---\\n\\n## On cr\xe9e un R\xe9seau Virtuel\\nSi nous avons envie que nos ressources discutent entre elles, il nous faut un r\xe9seau.\\n\\nPour cr\xe9er un adaptateur virtuel, il suffit d\u2019appeler la ressource `proxmox_virtual_environment_network_linux_bridge` et de lui donner un nom :  \\n\\n```hcl\\nresource \\"proxmox_virtual_environment_network_linux_bridge\\" \\"internal_network\\" {\\n  node_name = var.target_node\\n  name      = \\"vmbr5\\"\\n  comment   = \\"Internal Network\\"\\n}\\n```\\n\\n---\\n\\n## Votre premier Container  \\n\\nPassons aux choses concr\xe8tes en instanciant un **LXC**. Pour cela, nous cr\xe9ons une ressource `proxmox_virtual_environment_container`.  \\n\\nAvec l\u2019IaC, tout peut \xeatre configur\xe9 : le disque, la RAM, le serveur DNS, etc.  \\n\\n```hcl\\nresource \\"proxmox_virtual_environment_container\\" \\"first_lxc\\" {\\n  description   = \\"Managed by Terraform - Mr.VyM\\"\\n  node_name     = var.target_node\\n  start_on_boot = true\\n  started       = true\\n\\n  vm_id = 101\\n\\n  cpu {\\n    architecture = \\"amd64\\"\\n    cores        = var.core_nb\\n  }\\n\\n  disk {\\n    datastore_id = \\"storage\\"\\n    size         = var.disk_size\\n  }\\n\\n  memory {\\n    dedicated = var.memory_size\\n    swap      = 0\\n  }\\n\\n  operating_system {\\n    template_file_id = proxmox_virtual_environment_download_file.ubuntu_22-04_lxc.id\\n    type             = \\"ubuntu\\"\\n  }\\n\\n  initialization {\\n    hostname = \\"mycontainer\\"\\n\\n    dns {\\n      servers = [\\"1.1.1.1\\", \\"1.0.0.1\\"]\\n    }\\n\\n    ip_config {\\n      ipv4 {\\n        address = \\"192.168.10.2/24\\"\\n        gateway = \\"192.168.10.1\\"\\n      }\\n    }\\n\\n    user_account {\\n      keys     = [\\"keys 1\\", \\"keys 2\\"]\\n      password = var.lxc_password\\n    }\\n  }\\n\\n  network_interface {\\n    bridge = proxmox_virtual_environment_network_linux_bridge.internal_network.name\\n    name   = \\"eth0\\"\\n  }\\n}\\n```\\n\\n---\\n\\n## Et maintenant une VM  \\n\\nCr\xe9er une VM suit le m\xeame pattern que pour un LXC, avec quelques diff\xe9rences :  \\n\\n```hcl\\nresource \\"proxmox_virtual_environment_vm\\" \\"vm_template\\" {\\n  description = \\"Managed by Terraform - Mr.VyM\\"\\n  node_name   = var.target_node\\n\\n  name        = \\"MyDummyVM\\"\\n  vm_id       = 102\\n\\n  cpu {\\n    cores = var.core_nb\\n    type  = \\"x86-64-v2-AES\\"  # recommand\xe9 pour les CPU modernes\\n  }\\n\\n  memory {\\n    dedicated = var.memory_size\\n    floating  = var.memory_size # active le ballooning\\n  }\\n\\n  disk {\\n    datastore_id = \\"local\\"\\n    file_id      = proxmox_virtual_environment_download_file.ubuntu_22-04_img.id\\n    interface    = \\"scsi0\\"\\n    size         = var.disk_size\\n  }\\n\\n  initialization {\\n    ip_config {\\n      ipv4 {\\n        address = \\"${var.base_subnet}.3/24\\"\\n        gateway = \\"${var.base_subnet}.1\\"\\n      }\\n    }\\n\\n    user_account {\\n      keys     = [\\"keys 1\\", \\"keys 2\\"]\\n      password = var.vm_password \\n      username = \\"mrvym\\"\\n    }\\n\\n    datastore_id = \\"local\\"\\n  }\\n\\n  network_device {\\n    bridge = proxmox_virtual_environment_network_linux_bridge.internal_network.name\\n  }\\n\\n  operating_system {\\n    type = \\"l26\\" # Linux Kernel\\n  }\\n}\\n```\\n\\n---\\n\\n## On check et ca part en Prod\\n\\nEnfin, nous d\xe9ployons le tout avec les commandes suivantes :  \\n\\n- **`terraform init`**  \\n  Initialise Terraform, t\xe9l\xe9charge les providers et cr\xe9e les fichiers `terraform.state` et `terraform.lock`. Ces fichiers stockent l\u2019\xe9tat des entit\xe9s sur le serveur.  \\n  Si ces fichiers sont absents, Terraform recr\xe9e les ressources, ce qui pourrait entra\xeener leur suppression et recr\xe9ation.  \\n\\n- **`terraform fmt`**  \\n  Formate le code pour garantir sa propret\xe9.  \\n\\n- **`terraform plan`**  \\n  V\xe9rifie les actions que Terraform s\u2019appr\xeate \xe0 ex\xe9cuter.  \\n\\n- **`terraform apply`**  \\n  Applique les modifications.\\n\\n\\n\\n\\n\\n\\n> Ecrit pour l\'**`Avent of Tech`** de la [JECT](https://dev.to/ject)"},{"id":"disque-dur-sas-sata-scsi-ide","metadata":{"permalink":"/disque-dur-sas-sata-scsi-ide","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2024-09-07-SAS-or-not-SAS/index.md","source":"@site/blog/2024-09-07-SAS-or-not-SAS/index.md","title":"Disque dur : SAS, SATA, SCSI ou IDE ?","description":"Notre but dans cet article est de mieux comprendre le concept des interfaces mat\xe9rielles / programmation, des couches physiques et des jeux de commandes, et plus simplement des syst\xe8mes de stockage qui nous entourent.","date":"2024-11-07T00:00:00.000Z","tags":[{"inline":true,"label":"SSD","permalink":"/tags/ssd"},{"inline":true,"label":"SAS","permalink":"/tags/sas"},{"inline":true,"label":"Hardware","permalink":"/tags/hardware"},{"inline":true,"label":"Storage","permalink":"/tags/storage"}],"readingTime":4.026666666666666,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"disque-dur-sas-sata-scsi-ide","title":"Disque dur : SAS, SATA, SCSI ou IDE ?","tags":["SSD","SAS","Hardware","Storage"],"hide_title":false,"date":"2024-11-07T00:00:00.000Z","authors":["mrvym"]},"unlisted":false,"prevItem":{"title":"Introduction \xe0 Terraform avec Proxmox","permalink":"/intro-terraform-proxmox"},"nextItem":{"title":"#define INC(a) INC(a+1)","permalink":"/define-inc-a-inc-a+1"}},"content":"Notre but dans cet article est de mieux comprendre le concept des interfaces mat\xe9rielles / programmation, des couches physiques et des jeux de commandes, et plus simplement des syst\xe8mes de stockage qui nous entourent.\\n\\n\x3c!-- truncate --\x3e \\nMais d\'abord, un \\"rapide\\" r\xe9capitulatif de l\'\xe9tat actuel de nos p\xe9riph\xe9riques de stockage :\\n\\n| Norme de stockage  | Interface mat\xe9rielle        | Couche physique                          | Jeux de commandes                  |\\n|--------------------|-----------------------------|------------------------------------------|------------------------------------|\\n| PATA               | IDE (Integrated Drive Electronics) | Connecteur 40/44 broches, c\xe2ble parall\xe8le | ACS (ATA Command Set)              |\\n| SATA               | SATA (Serial ATA)           | Connecteur SATA, c\xe2ble s\xe9rie             | ACS (ATA Command Set)              |\\n| SAS (Serial Attached SCSI) | SCSI (Small Computer System Interface) | Connecteur SAS, c\xe2ble s\xe9rie              | SCSI (Small Computer System Interface) |\\n| NVMe (Non-Volatile Memory Express) | PCIe (Peripheral Component Interconnect Express) | Bus PCIe | AHCI (Advanced Host Controller Interface) |\\n\\nSi vous vous demandez, oui, les constructeurs ont pris un malin plaisir \xe0 utiliser le m\xeame nom entre l\'interface et la norme.\\n\\n--\\nAvant de commencer, un point vocabulaire\\n> Couche Physique : C\'est le cable et le connecteur.\\n\\n> Interface Materielle : C\'est la maniere de communiquer, attention ne pas confondre avec le \\"language\\". \\n\\n> Jeu de commandes : C\'est le language utilis\xe9.\\n\\nPour faire une analogie, si vous etes un humain (j\'espere :thinking:), la couche physique c\'est vos cordes vocales, l\'interface materielle, c\'est la maniere de faire vibrer vos cordes et le jeu de commandes, c\'est le language utilis\xe9. \\n\\n## Norme de stockage\\n\\n### ATA \\n> Date : 1986  \\n> Qui : Western Digital  \\n\\nATA signifie **Advanced Technology Attachment**.\\n\\nC\'est le v\xe9ritable concurrent du protocole SCSI. C\'est aussi un ensemble de normes avec l\'interface mat\xe9rielle (IDE), la couche physique (PATA ou bien SATA) et les jeux de commandes (ACS).\\n\\nC\'est une version plus low-cost de SCSI, qui avait pour but de r\xe9utiliser des \xe9l\xe9ments de ce dernier mais en simplifiant le connecteur (la couche physique) et le jeu d\'instruction.\\n\\nContrairement au SAS, cette norme est en semi-duplex, ce qui signifie qu\'elle ne peut ex\xe9cuter qu\'une seule action simultan\xe9ment : soit lire, soit \xe9crire.\\n\\n### SAS \\n\\n> Date : 1980  \\n> Qui : Shugart / NCR Corporation  \\n\\nC\'est un ensemble de normes qui s\'applique sur les couches physiques et les jeux de commandes. \\n\\nNous devons revenir dans les ann\xe9es 80, \xe0 cette \xe9poque, il n\'y a pas des milliers de fa\xe7ons de communiquer avec un p\xe9riph\xe9rique de stockage. L\'un d\'entre eux est le protocole **SCSI** (Small Computer System Interface).\\n\\nC\'est un protocole propri\xe9taire mais tr\xe8s performant pour son temps. Son grand avantage est le fait de d\xe9porter la logique dans le p\xe9riph\xe9rique, contrairement \xe0 ses concurrents qui utilisent all\xe8grement la puissance de l\'ordinateur. Et dans les ann\xe9es 80, on n\'avait pas encore la puissance de calcul, ce protocole a donc \xe9t\xe9 particuli\xe8rement appr\xe9ci\xe9 par l\'industrie.\\n\\nDe plus, la norme a l\'avantage de pouvoir \xe9crire en duplex, c\'est-\xe0-dire lire et \xe9crire des donn\xe9es simultan\xe9ment.\\n\\n## Interface mat\xe9rielle\\n\\n### IDE\\n\\nIDE est une norme qui int\xe8gre le contr\xf4leur de disque directement sur le disque dur lui-m\xeame. Avant IDE, les contr\xf4leurs de disque \xe9taient s\xe9par\xe9s, ce qui compliquait la configuration et limitait la compatibilit\xe9.  \\nCela signifie qu\'un disque dur est dit compatible IDE s\'il poss\xe8de une puce IDE.\\n\\n### SATA\\n\\nC\'est une r\xe9-impl\xe9mentation de l\'interface mat\xe9rielle parall\xe8le en s\xe9rie (Serial ATA).\\n\\n> Qu\'est-ce qu\'un port parall\xe8le ?  \\n> Contrairement au port s\xe9rie, un port parall\xe8le peut transf\xe9rer un ensemble de 8 bits \xe0 la fois sur huit fils diff\xe9rents.\\n\\nPour vous donner une id\xe9e de l\'interface mat\xe9rielle / couche physique.\\n![PATA Pin-out](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/si132dwg6anuqybjfeal.png)\\n\\n### PCIe\\n\\nL\'interface mat\xe9rielle PCIe (Peripheral Component Interconnect Express) est une interface de communication utilis\xe9e principalement pour connecter des p\xe9riph\xe9riques internes tels que des cartes graphiques, des cartes r\xe9seau et d\'autres cartes d\'extension.\\n\\nElle utilise un bus s\xe9rie, ce qui signifie que les donn\xe9es sont transmises bit par bit sur une seule ligne, contrairement aux anciennes interfaces parall\xe8les.\\n\\nPCIe fonctionne avec des connecteurs sp\xe9cifiques et des voies de transmission (lanes) qui permettent des transferts de donn\xe9es tr\xe8s rapides. \\n\\nLes cartes PCIe sont ins\xe9r\xe9es dans des slots PCIe sur la carte m\xe8re, et l\'interface est disponible en diff\xe9rentes versions (x1, x4, x8, x16) en fonction du nombre de voies utilis\xe9es, offrant ainsi une bande passante ajust\xe9e aux besoins des p\xe9riph\xe9riques.\\n\\nPCIe est largement utilis\xe9 dans les syst\xe8mes modernes en raison de sa vitesse de transmission \xe9lev\xe9e, de sa flexibilit\xe9 et de sa capacit\xe9 \xe0 \xe9voluer pour prendre en charge des dispositifs n\xe9cessitant des d\xe9bits importants.\\n\\n## Couche physique\\n\\nGlobalement, c\'est la partie la plus simple de l\'article.  \\n(Enfin, en \xe9lectronique, ce n\'est jamais simple).\\n\\nUne couche physique, cela signifie que c\'est la norme qui r\xe9git la fa\xe7on de r\xe9aliser le c\xe2ble et le connecteur (cf Illustration du Pin-out)\\n\\n\\n\\nUne nappe IDE\\n![Nappe IDE](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/fu04kfy2js7vjn27lbpg.jpg)\\nDans notre cas, c\'est un c\xe2ble dit \\"IDE\\".  \\nCe genre de c\xe2ble est la version parall\xe8le, il contient 80 fils, ce qui permet de connecter deux appareils \xe0 la carte m\xe8re. Le premier sera appel\xe9 \\"master\\" et le deuxi\xe8me \\"slave\\".\\n\\n\\n![Master Slave PATA](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/10bq0ctd4sh4ettg1514.png)\\nMais je ne vais pas d\xe9tailler les diff\xe9rents c\xe2bles qui existent.\\n\\n## Jeux de commandes\\n\\n### ACS (Commandes)\\n> Date : ann\xe9es 80  \\n> Qui : Shugart / NCR Corporation\\n\\nLe **ATA Command Set** (ACS) est la liste des commandes que le syst\xe8me peut envoyer au p\xe9riph\xe9rique.  \\nOn pourrait citer comme exemples :  \\n- WRITE_SECTOR  \\n- SLEEP  \\n- PACKET  \\n- IDENTIFY PACKET DEVICE\\n\\n### SCSI\\n\\nACS \xe9tant un d\xe9tournement du jeu de SCSI, on retrouve de grandes similitudes entre les deux jeux. Cependant, on peut les diff\xe9rencier en creusant un peu, notamment en ce qui concerne les rapports d\'erreurs.\\n\\n### AHCI\\n\\n**AHCI** (Advanced Host Controller Interface) permet une communication optimis\xe9e entre le syst\xe8me d\'exploitation et les p\xe9riph\xe9riques de stockage, en offrant des fonctionnalit\xe9s avanc\xe9es comme le contr\xf4le de file d\'attente (pour am\xe9liorer les lectures/\xe9critures simultan\xe9es) et le mode **NCQ** (Native Command Queuing), qui permet au disque de r\xe9organiser les commandes d\'entr\xe9e/sortie pour une performance maximale.\\n\\nCe jeu de commandes facilite \xe9galement des fonctionnalit\xe9s telles que la gestion de l\'alimentation et le **hot-plug** (permettre l\'ajout et le retrait de p\xe9riph\xe9riques sans \xe9teindre le syst\xe8me).\\n\\nAHCI a \xe9t\xe9 con\xe7u pour am\xe9liorer les performances et la gestion des p\xe9riph\xe9riques de stockage SATA en optimisant l\'utilisation des ressources et la vitesse des transferts.\\n\\n# Conclusion / Performance\\n\\nNous n\'avons toujours pas parl\xe9 de la partie performance de ces diff\xe9rences, donc voici le mot de la fin.\\n\\n| Interface    | Vitesse max (Gb/s)       | Type de connexion | Utilisation principale                    |\\n|--------------|--------------------------|-------------------|-------------------------------------------|\\n| **SATA III** | 6 Gb/s                   | S\xe9rie            | SSD et HDD domestiques                   |\\n| **SAS**      | 22,5 Gb/s                | S\xe9rie            | Disques professionnels et serveurs       |\\n| **PCIe 5.0** | 32 Gb/s par ligne        | S\xe9rie            | SSD NVMe internes                        |\\n| **NVMe**     | D\xe9pend de PCIe           | PCIe             | SSD haute performance                    |\\n| **U.2**      | Selon PCIe (16-32 Gb/s)  | PCIe et NVMe     | Serveurs et stations de travail          |\\n| **M.2**      | Selon PCIe (16-32 Gb/s)  | PCIe ou SATA     | Ordinateurs portables et de bureau       |\\n| **Thunderbolt 3/4** | 40 Gb/s           | S\xe9rie (USB-C)    | Stockage externe rapide                  |\\n| **USB 4**    | 40 Gb/s                  | S\xe9rie (USB-C)    | Stockage externe polyvalent              |"},{"id":"define-inc-a-inc-a+1","metadata":{"permalink":"/define-inc-a-inc-a+1","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2024-08-17-Define-INC-a/index.md","source":"@site/blog/2024-08-17-Define-INC-a/index.md","title":"#define INC(a) INC(a+1)","description":"Le but de cet article est de vous faire d\xe9couvrir le magnifique univers des macros en C.","date":"2024-08-17T00:00:00.000Z","tags":[{"inline":true,"label":"define","permalink":"/tags/define"},{"inline":false,"label":"C Language","permalink":"/tags/c","description":"The most wonderful language"},{"inline":true,"label":"macro","permalink":"/tags/macro"}],"readingTime":7.033333333333333,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"define-inc-a-inc-a+1","title":"#define INC(a) INC(a+1)","tags":["define","C","macro"],"hide_title":false,"authors":["mrvym"]},"unlisted":false,"prevItem":{"title":"Disque dur : SAS, SATA, SCSI ou IDE ?","permalink":"/disque-dur-sas-sata-scsi-ide"},"nextItem":{"title":"Le Merveilleux Monde de Make","permalink":"/le-merveilleux-monde-de-make"}},"content":"Le but de cet article est de vous faire d\xe9couvrir le magnifique univers des macros en C.\\n\\n# Une directive pr\xe9processeur\\nEn C, les lignes qui commencent par un # sont interpr\xe9t\xe9es par le compilateur lors de la compilation des fichiers sources. On les appelle des directives du pr\xe9processeur. Les macros en font partie.\\n\\nPetit point historique : \\n> Les macros en langage C ont \xe9t\xe9 introduites avec la premi\xe8re norme du langage C, appel\xe9e ANSI C (ou C89), \\n> qui a \xe9t\xe9 standardis\xe9e par l\'[American National Standards Institute](https://www.ansi.org) (ANSI) en 1989.\\n> \\n> Cependant, avant cette standardisation, les macros faisaient d\xe9j\xe0 partie du langage C classique (ou K&R C) utilis\xe9 dans les ann\xe9es 1970. \\n> Le compilateur C original, d\xe9velopp\xe9 par Dennis Ritchie pour le syst\xe8me d\'exploitation UNIX, incluait d\xe9j\xe0 une forme rudimentaire de macros via le pr\xe9processeur, permettant des d\xe9finitions avec #define.\\n\\n\x3c!-- truncate --\x3e \\n# Define \\n```c\\n#define SENS_DE_LA_VIE 3.14\\n\\n/* ... */\\n\\nprintf(\\"%f\\\\n\\", SENS_DE_LA_VIE);\\n```\\nLe `define` a un fonctionnement assez simple \xe0 comprendre : le compilateur remplace toutes les occurrences dans le code par la valeur d\xe9finie. Il fonctionne avec la syntaxe suivante `#define <MACRO_NAME> <value>`. On a pour convention de mettre le nom en majuscule, la valeur quant \xe0 elle est optionnelle.\\n\\nUn peu comme un \\"Ctrl-f et remplacer\\".\\n\\n## Mama, la macro\\nOn peut utiliser les `define` pour d\xe9finir des fonctions que l\'on pourra utiliser dans notre code.\\n\\n```c\\n#define INC(a) a++ \\n#define MULTI_LINE(a,b) a = b; \\\\\\n                        b = 0; \\n\\n\\nINC(my_variable); \\nMULTI_LINE(my_variable, foobar) \\n// Je souligne le fait qu\'il peut ne pas y avoir de \';\' en fin de ligne \\n\\n// Cela donnera  \\nmy_variable++;\\nmy_variable = foobar;\\nfoobar = 0;\\n```\\n\\n## If or not if\\nNous pouvons d\xe9clarer des macros de mani\xe8re conditionnelle. \\nSi un nom est d\xe9j\xe0 d\xe9fini alors on ex\xe9cute le bout de code suivant. \\n```c\\n#ifdef DEBUG\\n// Je souligne qu\'il est rarement conseill\xe9 d\'utiliser des printf() en debug\\n// et que nous avons bris\xe9 la r\xe8gle du nom des macros en MAJ.\\n#define return printf(\\"(%s:%d)\\\\n\\", __FUNCTION__, __LINE__);  return\\n#endif /* ! DEBUG */\\n\\nint main(void) {\\n    return 1;\\n}\\n```\\nDans ce cas, j\'utilise un `#ifndef`, mais il existe aussi :\\n- `#ifdef`\\n- `#if`\\n- `#else`\\n- `#elif`\\n```c\\n#if (X == 1)\\n#define Y 2\\n#elif (X == 2)\\n#define Y \\"Ami de la bonne blague, bonjour !\\"\\n#else\\n#define Y NULL\\n#endif /* ! X */\\n\\n/* ... */\\n\\nint main(void) {\\n    #if (X == 1)\\n    printf(\\"%d\\\\n\\", Y);\\n    #else \\n    printf(\\"%s\\\\n\\", Y);\\n    #endif /* ! X */\\n}\\n```\\n\\nOn aime bien signaler avec un commentaire en bloc la fin des `#if`. C\'est une convention qui permet de mieux se rep\xe9rer dans le code. \\n\\n## Macros pr\xe9d\xe9finies\\nVous avez pu voir dans l\'exemple pr\xe9c\xe9dent que j\'utilisais les mots-cl\xe9s `__FUNCTION__` et `__LINE__`. \\nComme vous pouvez vous en douter, ce sont des macros que le compilateur va remplacer par la bonne valeur.\\n\\nIl existe une liste de macros pr\xe9d\xe9finies [Common Predifined](https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html).\\n\\n\xc0 noter qu\'il existe des macros dites [System specific](https://gcc.gnu.org/onlinedocs/cpp/System-specific-Predefined-Macros.html).\\n\\nPetite liste non exhaustive : \\n- `__DATE__` : Jan 14 2012\\n- `__GNUC__` : Version majeure de GCC\\n- `__TIME__` : 15:12:18\\n- `__INCLUDE_LEVEL__` : La profondeur des includes en commen\xe7ant par 0\\n- `__BASE_FILE__` : Le nom du fichier actuel\\n\\n## Vers l\'infini et au-del\xe0 des arguments\\n```c\\n// Ici, l\'op\xe9rateur ## est l\'op\xe9rateur de concat\xe9nation\\n#define DEBUG_PRNTF(fmt, ...) printf(\\"LOG\\" ## fmt, __VA_ARGS__);\\n```\\nIci, on peut voir que l\'on g\xe9n\xe8re des macros variadiques, surtout utiles lors de la cr\xe9ation de logs. \\n(M\xeame si ce n\'est pas une bonne id\xe9e de faire des logs avec des `printf`.)\\n\\n## X-Macro\\n\\nPour cela, nous allons devoir cr\xe9er un fichier externe, souvent nomm\xe9 en `*.def` bien qu\'il n\'existe pas de convention.\\n```c\\n// color.def\\nX(NC, \\"\\\\e[0m\\", \\"No Color\\", 0x000000) \\nX(BLACK, \\"\\\\e[0;30m\\", \\"Black\\", 0x000000) \\nX(GRAY, \\"\\\\e[1;30m\\", \\"Gray\\", 0x808080) \\nX(RED, \\"\\\\e[0;31m\\", \\"Red\\", 0xFF0000) \\nX(LIGHT_RED, \\"\\\\e[1;31m\\", \\"Light Red\\", 0xFF8080) \\nX(GREEN, \\"\\\\e[0;32m\\", \\"Green\\", 0x00FF00) \\nX(LIGHT_GREEN, \\"\\\\e[1;32m\\", \\"Light Green\\", 0x80FF80) \\nX(BROWN, \\"\\\\e[0;33m\\", \\"Brown\\", 0xA52A2A) \\nX(YELLOW, \\"\\\\e[1;33m\\", \\"Yellow\\", 0xFFFF00) \\nX(BLUE, \\"\\\\e[0;34m\\", \\"Blue\\", 0x0000FF) \\nX(LIGHT_BLUE, \\"\\\\e[1;34m\\", \\"Light Blue\\", 0xADD8E6) \\nX(PURPLE, \\"\\\\e[0;35m\\", \\"Purple\\", 0x800080) \\nX(LIGHT_PURPLE, \\"\\\\e[1;35m\\", \\"Light Purple\\", 0xEE82EE) \\nX(CYAN, \\"\\\\e[0;36m\\", \\"Cyan\\", 0x00FFFF) \\nX(LIGHT_CYAN, \\"\\\\e[1;36m\\", \\"Light Cyan\\", 0xE0FFFF) \\nX(LIGHT_GRAY, \\"\\\\e[0;37m\\", \\"Light Gray\\", 0xD3D3D3) \\nX(WHITE, \\"\\\\e[1;37m\\", \\"White\\", 0xFFFFFF)\\n```\\n\\n```c\\ntypedef struct {\\n    const char *name;        \\n    const char *ansi_code;  \\n    const char *description;\\n    unsigned int rgb;      \\n} Color;\\n\\n#define X(NAME, ANSI, DESC, RGB) { #NAME, ANSI, DESC, RGB },\\nColor colors[] = {\\n    #include \\"color.def\\"\\n};\\n#undef X\\n\\n#define X(NAME, ANSI, DESC, RGB) printf(\\"%s (%s) = %s\\\\n\\", #NAME, DESC, #RGB);\\nvoid print_colors() {\\n    // Bien entendu, on pourrait it\xe9rer sur la structure cr\xe9\xe9e mais c\'est une illustration\\n    #include \\"color.def\\"\\n}\\n#undef X\\n```\\nCe genre de macro est extr\xeamement utile. Je dois reconna\xeetre qu\'on la retrouve rarement dans un code source, mais elle permet de modifier le fonctionnement du programme sans pour autant devoir modifier le code source. Fun fact, elle est souvent utilis\xe9e dans la cr\xe9ation de kernels. Elle permet de g\xe9n\xe9rer les structures globales comme l\'IDT et la GDT.\\n\\n## Les probl\xe8mes \\n__**Attention**__ : Petite mise au point d\'abord, les macros sont des outils formidables mais il faut faire attention. Vous ne devez surtout pas utiliser ce genre de macro :\\n```c\\n#define MIN(a,b) (a < b ? a : b)\\n```\\n\\nPrenons un exemple : `MIN(2 + 5, fibo(25))`\\n### Probl\xe8me n\xb01 \\n`MIN(2 + 5, fibo(25))` => `(2 + 5 < fibo(25) ? 2 + 5 : fibo(25))`\\n\\nIci le probl\xe8me est la priorit\xe9 de calcul. Le compilateur va d\'abord effectuer la comparaison puis l\'addition, donc 2 + (1). On corrige cela par l\'ajout de parenth\xe8ses en utilisant les arguments des macros.\\n```c\\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\\n```\\nComme vous ne savez jamais ce que vos utilisateurs vont passer en param\xe8tre, mettez toujours des parenth\xe8ses sur les arguments.\\n### Probl\xe8me n\xb02 \\n`MIN(2 + 5, fibo(25))` => `(2 + 5 < fibo(25) ? 2 + 5 : fibo(25))`\\n\\nOn remarque que le compilateur fait un remplacement b\xeate et m\xe9chant, ce qui veut dire que l\'on va calculer deux fois `fibo(25)`. Je vous laisse imaginer si c\'est une impl\xe9mentation r\xe9cursive.\\n\\nPour fixer ce probl\xe8me, nous d\xe9clarons une variable interm\xe9diaire avant le `if`. \\n## Macros utiles\\n\\n```c\\n#define MIN(a, b)                                                              \\\\\\n    ({                                                                         \\\\\\n        __typeof__(a) _a = a;                                                  \\\\\\n        __typeof__(b) _b = b;                                                  \\\\\\n        (_a) > (_b) ? (_b) : (_a);                                             \\\\\\n    })\\n\\n#define ABS(a)                                                                 \\\\\\n    ({                                                                         \\\\\\n        __typeof__(a) _a = a;                                                  \\\\\\n        0 < (_a) ? (_a) : -(_a);                                               \\\\\\n    })\\n\\n#define MAX(a, b)                                                              \\\\\\n    ({                                                                         \\\\\\n        __typeof__(a) _a = a;                                                  \\\\\\n        __typeof__(b) _b = b;                                                  \\\\\\n        (_a) < (_b) ? (_b) : (_a);                                             \\\\\\n    })\\n\\n#define CLAMP(a, x, b) MAX(a, MIN(x, b))\\n// Pour les tableaux uniquement\\n#define COUNT_OF(arr) sizeof(arr) / sizeof(arr[0])\\n```\\n\\n## L\xe0, on s\'amuse\\nIci, c\'est du code purement overkill juste pour le fun. Je ne vous conseille pas forc\xe9ment d\'utiliser ces macros dans votre code.\\nJe me fais juste plaisir (faut bien dans la vie).\\n\\n### Un auto free\\n\\n```c\\n#define DEFER(free_call) __attribute__((cleanup(free_call)))\\n\\nvoid auto_free(void *ptr) {\\n    void **p = (void **)ptr;\\n    if (*p) {\\n        free(*p);\\n        *p = NULL;\\n    }\\n}\\n\\nint main() {\\n  DEFER(auto_free) char* buffer = malloc(10);\\n  return 0;\\n}\\n```\\n\\nJe vous laisse tester avec un petit `-fsanitize=address`. C\'est vraiment une dinguerie. On pourrait m\xeame voir une am\xe9lioration de la fonction auto_free qui prend en param\xe8tre une cha\xeene de caract\xe8res du nom de notre structure pour faire un switch.\\n\\n### Get time\\n\\nFonction plus chill o\xf9 l\'on calcule juste le temps d\'ex\xe9cution de notre fonction. Tr\xe8s utile pour faire du benchmark.\\n\\n```c\\n#define MEASURE_TIME(block) {                                \\\\\\n    clock_t start_time = clock();                            \\\\\\n    block                                                    \\\\\\n    clock_t end_time = clock();                              \\\\\\n    double elapsed = ((double)(end_time - start_time)) / CLOCKS_PER_SEC * 1000.0; \\\\\\n    printf(\\"Execution time: %.3f ms\\\\n\\", elapsed);            \\\\\\n}\\n```\\n\\n### Define Error\\n\\nPetite X-macro qui prend une macro en argument et qui l\'expand.\\n\\n```c\\n#define ERROR_LIST(X)          \\\\\\n    X(ERROR_FILE_NOT_FOUND, \\"File not found\\")    \\\\\\n    X(ERROR_INVALID_INPUT, \\"Invalid input\\")      \\\\\\n    X(ERROR_OUT_OF_MEMORY, \\"Out of memory\\")      \\\\\\n    X(ERROR_UNKNOWN, \\"Unknown error\\")\\n\\n#define DEFINE_ERROR_ENUM(code, message) code,\\nenum ErrorCode {\\n    ERROR_LIST(DEFINE_ERROR_ENUM)\\n};\\n\\n#define DEFINE_ERROR_STRING(code, message) case code: return message;\\nconst char* get_error_message(enum ErrorCode error_code) {\\n    switch (error_code) {\\n        ERROR_LIST(DEFINE_ERROR_STRING)\\n        default: return \\"Unrecognized error\\";\\n    }\\n}\\n\\n/* ... */\\nenum ErrorCode error = ERROR_OUT_OF_MEMORY;\\nprintf(\\"Error: %s\\\\n\\", get_error_message(error));\\n```\\n\\n### G\xe9n\xe9ration de tests automatis\xe9s\\n\\nIci, on g\xe9n\xe8re carr\xe9ment des fonctions enti\xe8res avec une macro, parce que le C n\'a aucune limite. Moi aussi :eyes:\\n```c\\n#define GENERATE_TEST_FUNC(func, test_value, wanted_value) \\\\\\n    void test_##func(void) { \\\\\\n        printf(\\"Test de \\" #func \\" avec valeur %d : \\", test_value); \\\\\\n        if (func(test_value)) { \\\\\\n            printf(\\"Succ\xe8s\\\\n\\"); \\\\\\n        } else { \\\\\\n            printf(\\"\xc9chec\\\\n\\"); \\\\\\n        } \\\\\\n    }\\n\\n/* ... */\\nGENERATE_TEST_FUNC(fibo, 10, 55);\\n\\ntest_fibo();\\n```\\n\\n## RTFM\\n\\nIl est maintenant l\'heure de conclure. Nous avons vu plein de choses tr\xe8s cool. Et si jamais vous \xeates tent\xe9s, libre \xe0 vous de d\xe9couvrir les macros par vous-m\xeame.\\nDonc, conclusion : **RTFM**.\\n\\n> PS : Pour ce qui est du titre, les macros ne sont pas r\xe9cursives, elles ne s\'expandent qu\'avec une profondeur de 1."},{"id":"le-merveilleux-monde-de-make","metadata":{"permalink":"/le-merveilleux-monde-de-make","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2024-03-14-Merveilleux-Monde-de-Make/index.md","source":"@site/blog/2024-03-14-Merveilleux-Monde-de-Make/index.md","title":"Le Merveilleux Monde de Make","description":"Les Makefiles constituent un outil essentiel dans le d\xe9veloppement de logiciels que ce soit en C/C++ ou autre. Ils permettent une gestion efficace des projets en automatisant le processus de compilation, de nettoyage et de tests.","date":"2024-03-14T00:00:00.000Z","tags":[{"inline":true,"label":"make","permalink":"/tags/make"},{"inline":false,"label":"C Language","permalink":"/tags/c","description":"The most wonderful language"},{"inline":true,"label":"c++","permalink":"/tags/c"},{"inline":true,"label":"criterion","permalink":"/tags/criterion"}],"readingTime":7.14,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"le-merveilleux-monde-de-make","title":"Le Merveilleux Monde de Make","authors":["mrvym"],"tags":["make","C","c++","criterion"]},"unlisted":false,"prevItem":{"title":"#define INC(a) INC(a+1)","permalink":"/define-inc-a-inc-a+1"}},"content":"Les Makefiles constituent un outil essentiel dans le d\xe9veloppement de logiciels que ce soit en C/C++ ou autre. Ils permettent une gestion efficace des projets en automatisant le processus de compilation, de nettoyage et de tests. \\n\\nDans cet article, nous explorerons les bonnes pratiques pour la cr\xe9ation et l\'utilisation de Makefiles dans des projets C quelque soit leurs complexit\xe9s.\\n\\n\x3c!-- truncate --\x3e\\n### Make, ca sert a quoi ?\\n\\nMake est un programme qui a pour but de g\xe9n\xe9rer des fichier. Il permet de g\xe9n\xe9rer des pdfs, des ex\xe9cutables et bien plus.\\n\\n> Dans les ann\xe9es 1970, la compilation des programmes devient de plus en plus longue et complexe, n\xe9cessitant de nombreuses \xe9tapes interd\xe9pendantes. La plupart des syst\xe8mes alors utilis\xe9s reposent sur des script shell, n\xe9cessitant de r\xe9p\xe9ter toutes les \xe9tapes lors de la moindre correction. C\'est dans ce contexte que Make fut d\xe9velopp\xe9 par le docteur Stuart Feldman en 1977. En g\xe9rant les d\xe9pendances entre fichiers sources et fichiers compil\xe9s, Make permet de ne compiler que ce qui est n\xe9cessaire \xe0 la suite de la modification d\'un fichier source.\\n\\nIl existe un makefile par d\xe9faut, qui d\xe9finit un grand nombre de r\xe8gles afin de g\xe9n\xe9rer la plupart des fichiers avec lesquels, vous serez amen\xe9 a travailler.\\n\\nPour voir ce makefile, par d\xe9faut : `make -p`\\n\\n### Hello World \\n\\nPour d\xe9buter, nous allons prendre un cas tr\xe8s simple celui d\'un fichier source unique, dans le m\xeame dossier que notre makefile. \\n\\n```sh\\n.\\n\u2514\u2500\u2500 main.c \\n```\\nDans ce cas, il existe 2 facons de faire.\\n\\n```sh\\n$ make main # Je souligne l\'absence du .c\\n```\\n\\nDans cette commande, nous demandons a make de cr\xe9er le fichier `main`. Mais comment sait-il qu\'il doit utiliser le fichier main.c pour faire notre binaire ? Cela est d\xe9fini dans les r\xe8gles par d\xe9faut.\\n\\nNous pouvons aussi creer un fichier `Makefile`\\n\\n```makefile=\\n# Makefile\\nmy_compilation_rule: \\n    gcc main.c\\n```\\n\\nUne fois, le fichier cr\xe9e, il suffit d\'ex\xe9cuter la commande `make` (qui, par d\xe9faut, ex\xe9cute la premi\xe8re r\xe8gle du fichier).\\nNous pouvons aussi mettre en argument le nom de la r\xe8gle que nous voulons ex\xe9cuter `make my_compilation_rule`.\\n\\n### Plus on est de fou, plus on rit\\n\\nNotre projet grossit, nous avons maintenant un deuxi\xe8me fichier source.\\n```sh\\n.\\n\u251c\u2500\u2500 foo.c\\n\u251c\u2500\u2500 foo.h\\n\u2514\u2500\u2500 main.c \\n```\\n\\nDans l\'objectif de faire un makefile propre, nous allons d\xe9clarer une variable OBJ qui contiendra nos diff\xe9rents fichiers. On en profite pour d\xe9clarer un variable CC pour notre compilateur.\\n\\n```makefile\\n# makefile\\nCC = gcc\\nOBJ = main.o foo.o\\n\\n\\n# Cette variable sera utilis\xe9e dans la r\xe8gle implicite qui compile les .o  \\nCFLAGS = # My C Flags for the compiler\\nLDFLAGS = # My linker flags\\nTARGET = a.out\\n\\nall: $(OBJ)\\n\\t$(CC) $(OBJ) -o $(TARGET) $(LDFLAGS)\\n```\\n\\nCette fois-ci, nous avons ajouter des d\xe9pendances \xe0 notre r\xe8gle `all`. Maintenant, make sait qu\'il faut d\'abord faire les fichiers .o avant de pouvoir faire le linkage de tous les fichiers en un binaire.\\n\\n```makefile\\n# makefile\\nSRC = $(wildcard *.c) # main.c foo.c\\nOBJ = $(SRC:.c=.o) # main.o foo.o\\n```\\n\\nDans ce makefile, nous avons choisi de ne pas r\xe9cup\xe9rer, \xe0 la main, les diff\xe9rents fichiers source. Nous r\xe9cup\xe9rons automatiquement les fichiers source via la fonction `wildcard`. Cette fonction agit comme le globbing d\'un shell. Dans cette example, elle r\xe9cup\xe8re tous les fichiers terminant par `.c`. \\n\\nNous les convertissons en `.o` via cette syntax `$(NAME:old=new)` qui n\'est rien de moins qu\'un replace. La suite de notre makefile reste n\xe9anmoins la m\xeame chose.\\n\\n### Clean\\n\\nComme vous avez pu le remarquer, un makefile peut facilement g\xe9n\xe9rer un grand nombre de fichiers. C\'est pour cela que nous allons cr\xe9er une nouvelle r\xe8gle dans notre makefile qui a pour but de supprimer tous les fichiers issus de la compilation. \\n\\n```makefile\\n\\n# ...\\n\\nclean: \\n    $(RM) $(OBJ)\\n    $(RM) $(TARGET)\\n```\\n\\nPour les petits curieux qui se demandent ce que signifie la variable RM. C\'est un simple alias avec la commande `rm -f`. Il faut savoir que cette variable peut tr\xe8s bien override. On peut tr\xe8s bien voir `RM = echo` ou bien `RM = mv to/path/` (\xe0 la place du remove), cela peut \xeatre tr\xe8s utile dans certains projets.\\n\\n#### Phony\\n\\nNous l\'avons dit au d\xe9but de cet article, mais make est un utilitaire qui permet de g\xe9n\xe9rer des fichiers. Mais que se passe-t-il, si l\'on appelle la r\xe8gle clean et qui existe un fichier `clean` dans notre dossier. \\n```sh\\nmake: \'clean\' is up to date.\\n```\\n\\nPour \xe9viter ce genre de probl\xe8me, il faut sp\xe9cifier dans notre makefile que notre r\xe8gle n\'a pas pour but de g\xe9n\xe9rer un fichier. Pour cela, nous utilisons le mot cl\xe9 `phony`.\\n\\nIl suffit d\'\xe9crire. \\n```makefile\\n.PHONY: my_rule1 my_rule12 # ... \\n```\\n\\n### On range le repo\\nMaintenant, que nous avons r\xe9ussi \xe0 faire un makefile propre, nous allons pouvoir faire \xe9voluer notre projet en mettant nos fichiers dans un dossier `src`.\\n\\n```\\n.\\n\u251c\u2500\u2500 Makefile\\n\u2514\u2500\u2500 src/\\n    \u251c\u2500\u2500 foo.c\\n    \u251c\u2500\u2500 foo.h\\n    \u2514\u2500\u2500 main.c\\n```\\n\\nPour cela, il nous suffit de rechercher la liste de nos .c dans le dossier src/ puis de les transformer en .o. On peut modifier le code que nous avons fait ci-dessus.\\n\\n```makefile=\\nSRCDIR = src\\nSRC = $(wildcard $(SRCDIR)/*.c)\\nOBJ = $(SRC:$(SRCDIR)/%.c=$(SRCDIR)/%.o)\\n# qui est \xe9quivalent \xe0\\n# OBJ = src/main.o \\\\\\n#       src/main.o\\n\\n```\\n\\n### Where GDB ?\\nIl peut \xeatre utile d\'avoir un r\xe8gle debug, afin de ne pas avoir \xe0 mettre un `-g` dans nos CFLAGS par d\xe9faut.\\n\\nPour cela, il suffit de :\\n```makefile\\ndebug: CFLAGS += -g\\ndebug: all\\n```\\nOn remarque que la r\xe8gle debug n\'a pas de corps. Elle se contente d\'ajouter un flag et d\'appeler notre r\xe8gle `all`.\\n\\n### Tester, c\'est tricher \\n\\nPour cet article, nous allons voir comment faire un Makefile pour une test suite criterion.\\n```\\n.\\n\u251c\u2500\u2500 Makefile\\n\u251c\u2500\u2500 src/\\n...\\n\u2514\u2500\u2500 tests/\\n    \u2514\u2500\u2500 foo_test.c\\n```\\n\\nPour pouvoir lancer, nos tests, il va falloir que l\'on trouve les fichiers source du dossier `tests`, puis linker tous nos fichiers en excluant le fichier main.o.\\n\\n```makefile\\nTEST_DIR = tests\\nSRC_TEST = $(wildcard $(TEST_DIR)/*.c)\\nOBJ_TEST = $(SRC:$(TEST_DIR)/%.c=$(TEST_DIR)/%.o)\\n\\n# ... \\n\\ncheck: $(filter-out $(SRC_DIR)/main.o, $(OBJ)) $(OBJ_TEST)\\n$(CC) $^ -o $(TARGET) $(LDFLAGS)\\n```\\nOn remarque que le fichier main.o est exclus en utilisant la fonction `filter-out`. On voit aussi l\'appel d\'une variable pour le moment inconnu. Il en existe un grand nombre.\\n\\n- `$^`  : La liste des d\xe9pendances de la r\xe8gle\\n\\n- `$<` : Le nom de la premi\xe8re d\xe9pendance\\n\\n- `$@` : Le nom de la r\xe8gle\\n\\n\\n### On teste les tests\\n\\nSi l\'on parle de test, nous devons forc\xe9ment parler de coverage. Pour cela rien de plus simple, nous ajoutons les flags a nos variables puis ex\xe9cutons `GCOVR`\\n\\n```makefile=\\ncoverage: CFLAGS += -fPIC --coverage\\ncoverage: LDFLAGS += -lgcov -lcriterion\\ncoverage: check\\ngcovr --print-summary\\n```\\n\\n### Like a pro\\nLa cr\xe9ation d\'un dossier build est la cerise sur le g\xe2teau. Elle permet au d\xe9veloppeur de faire `rm -rf build/` pour faire un clean.\\n\\nPour cela, nous allons devoir modifier notre variable `OBJ` et nous allons devoir cr\xe9er un r\xe8gle pour la compilation des .o. Nous ne pouvons plus utiliser les r\xe8gles implicite.\\n\\n```makefile\\nBUILD_DIR = build\\nOBJ = $(SRC:$(SRC_DIR)/%.c=$(BUILD_DIR)/%.o)\\n\\n# Compilation des fichiers source\\n$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c | $(BUILD_DIR)\\n$(CC) $(CFLAGS) -c $< -o $@\\n    \\n# Creer le repertoire de build\\n$(BUILD_DIR):\\nmkdir -p $(BUILD_DIR)\\n```\\nAlors on remarque que cette fois-ci, nous n\'avons pas d\xe9fini une r\xe8gle, mais avec une variable. Nous avons m\xeame utilis\xe9 une sorte de regex pour la d\xe9finir. \\n\\nNous avons aussi d\xfb mettre un pr\xe9requis en plus, la r\xe8gle $(build_dir). Le fait de mettre un `|` signifie qu\'il doit d\'abord v\xe9rifier qu\'il est n\xe9cessaire de faire cette r\xe8gle.\\n\\n## Bonus\\n\\n### Biblioth\xe8que statique\\nPour cr\xe9er une biblioth\xe8que statique \xe0 partir des fichiers source, vous pouvez ajouter des r\xe8gles au Makefile :\\n```makefile\\nLIB_TARGET = libmylib.a\\nLIB_OBJS = $(filter-out $(BUILD_DIR)/main.o, $(OBJS))\\n\\n$(LIB_TARGET): $(LIB_OBJS)\\nar rcs $@ $^\\n```\\nUne fois, la librairie cr\xe9e, vous pourrez simplement la link avec votre binaire.\\n\\n### Makefile r\xe9cursif\\nSi votre projet comporte des sous-modules, vous pouvez utiliser un Makefile r\xe9cursif. Imaginons un projet avec la structure suivante.\\n\\n```sh\\n.\\n\u251c\u2500\u2500 Makefile\\n\u2514\u2500\u2500 src/\\n    \u251c\u2500\u2500 features1/\\n        ...\\n        \u2514\u2500\u2500 Makefile\\n    \u251c\u2500\u2500 features2/\\n        ...\\n        \u2514\u2500\u2500 Makefile\\n    \u251c\u2500\u2500 features3/\\n        ...\\n        \u2514\u2500\u2500 Makefile\\n    \u251c\u2500\u2500 features4/\\n        ...\\n        \u2514\u2500\u2500 Makefile\\n    \u251c\u2500\u2500 main.c\\n    \u2514\u2500\u2500 Makefile\\n```\\nPour cela, il y a deux approches possibles. La premi\xe8re serait de faire un seul makefile \xe0 la racine de notre projet et faire un find de nos fichiers .c. Nous verrons comment faire par la suite.\\n\\nLa deuxi\xe8me, c\'est de faire une structure r\xe9cursif via le Makefile suivant. \\n```makefile\\n# src/makefile \\nSUBDIRS = $(wildcard */.)\\n\\n.PHONY: subdirs $(SUBDIRS)\\n\\nsubdirs: $(SUBDIRS)\\n\\n$(SUBDIRS):\\n    $(MAKE) -C $@\\n```\\n\\nAvec ce fichier, nous allons pouvoir mettre un makefile dans chaque dossier features et lui et lui seul g\xe9rera la compilation de la features. Ils seront appel\xe9s par le `src/Makefile` via la r\xe8gles subdirs.\\n```makefile\\n# Makefile\\n\\nexport CFLAGS = -Wall -Werror -pedantic\\n\\n# ...\\n```\\nN\'oubliez pas d\'export vos variables dans votre Makefile afin qu\xb4elle s\'applique sur les Makefiles suivants.\\n\\nCe genre d\'architecture n\xe9cessite, la plupart du temps, de la combiner avec la cr\xe9ation de librairie statique.\\n### R\xe9pertoires infinis\\n\\nNous avons vu comment utiliser la fonction `wildcard` mais comment faire pour recuperer l\'int\xe9gralit\xe9 de nos fichiers sources ?\\n\\n```sh\\n\u251c\u2500\u2500 Makefile\\n\u2514\u2500\u2500 src/\\n    \u2514\u2500\u2500 foo/\\n        \u2514\u2500\u2500 bar/\\n            ...\\n                \u2514\u2500\u2500 foobar/\\n                    \u2514\u2500\u2500 barfoo/\\n                        \u2514\u2500\u2500 here.c\\n```\\nLa prise en charge des r\xe9pertoires \\"infinis\\" peut se faire via des r\xe8gles g\xe9n\xe9riques ou bien par l\'interm\xe9diaire d\'un sub-shell.\\n\\nPar exemple :\\n```makefile \\n# Attention, il faut que votre systeme possede la command find\\n\\nSRC = $(shell find $(SRC_DIR) -name \\"*.c\\")\\n```  \\nou bien\\n```makefile\\n# Je laisse les plus aventureux d\'entre vous dechiffrer ce code\\n\\nrwildcard = $(foreach d, $(wildcard $(1:=/*)), $(call rwildcard,$d,$2) $(filter $(subst *,%,$2),$d))\\nSRC = $(rwildcard src,*.c)\\n```\\nou encore \\n```makefile\\nSRC = $(wildcard src/*.c) \\\\\\n      $(wildcard src/*/*.c) \\\\\\n      # ... # \\n      $(wildcard src/*/*/*/*/*/*/*/*/*/*/.c)\\n# S\'il vous plait, ne faites pas ca \\n```\\n\\n## $ make conclusion\\n\\nEn conclusion, l\'utilisation judicieuse des Makefiles est cruciale pour la gestion efficace de projets. Il permet d\'\xe9conomiser \xe9norm\xe9ment de temps lors du processus de d\xe9veloppement. Ce n\'est pas pour rien que la quasi-int\xe9gralit\xe9 de l\'industrie utilise cet outil. \\n\\nCette article n\'\xe9tant bien entendu, pas exhaustif, je vous invite \xe0 vous renseigner par vous meme afin de d\xe9couvrir les autres fonctionnalit\xe9s de cet outil."}]}}')}}]);