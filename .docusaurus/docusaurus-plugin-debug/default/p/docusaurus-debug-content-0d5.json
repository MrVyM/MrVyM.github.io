{"allContent":{"docusaurus-plugin-content-blog":{"default":{"blogSidebarTitle":"...","blogPosts":[{"id":"protect-a-programm-to-pkill","metadata":{"permalink":"/protect-a-programm-to-pkill","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/ProtectPkill/ProtectPkill.md","source":"@site/blog/ProtectPkill/ProtectPkill.md","title":"Protect a program to Pkill","description":"","date":"2029-01-01T00:00:00.000Z","tags":[],"readingTime":0.01,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"unlisted":true,"authors":["mrvym"],"title":"Protect a program to Pkill","date":"2029-01-01T00:00:00.000Z","slug":"protect-a-programm-to-pkill"},"unlisted":false,"nextItem":{"title":"Sleep from Python to Electronics","permalink":"/sleep-from-python-to-electronics"}},"content":"<!-- truncate -->"},{"id":"sleep-from-python-to-electronics","metadata":{"permalink":"/sleep-from-python-to-electronics","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/SleepPythonToElec/SleepPythonToElec.md","source":"@site/blog/SleepPythonToElec/SleepPythonToElec.md","title":"Sleep from Python to Electronics","description":"sleep","date":"2029-01-01T00:00:00.000Z","tags":[{"inline":true,"label":"hardware","permalink":"/tags/hardware"},{"inline":false,"label":"C Language","permalink":"/tags/c","description":"The most wonderful language"},{"inline":true,"label":"Python","permalink":"/tags/python"}],"readingTime":0.29666666666666663,"hasTruncateMarker":true,"authors":[],"frontMatter":{"unlisted":true,"date":"2029-01-01T00:00:00.000Z","title":"Sleep from Python to Electronics","description":"sleep","slug":"sleep-from-python-to-electronics","tags":["hardware","C","Python"],"hide_title":false},"unlisted":false,"prevItem":{"title":"Protect a program to Pkill","permalink":"/protect-a-programm-to-pkill"},"nextItem":{"title":"Comment marche le bus 1-Wire ?","permalink":"/one-wire-protocol"}},"content":"## Python\n```py\nimport time\n# Here the time is in seconds\ntime.sleep(2)\n```\n<!-- truncate --> \n## C\n```c\n#include <unistd.h>\n\nint main(void) {\n  sleep(10);\n  return 0;\n}\n```\n\n## Coreutils\n```sh\nsleep 2\n# or \nsleep inf\n```\n\n## ASM\n### Syscall SYS_Nanosleep\n\n## STM32\n\n### Blocking \nHAL_Sleep(2)\n\n### No Blocking\nwhile \n\n## Elec \nGoes bruh"},{"id":"one-wire-protocol","metadata":{"permalink":"/one-wire-protocol","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2025-02-06-1-Wire-Protocol/index.md","source":"@site/blog/2025-02-06-1-Wire-Protocol/index.md","title":"Comment marche le bus 1-Wire ?","description":"Dans cet article, nous allons voir comment marche un bus un peu particulier.","date":"2025-02-06T00:00:00.000Z","tags":[{"inline":true,"label":"bus","permalink":"/tags/bus"},{"inline":true,"label":"1-wire","permalink":"/tags/1-wire"}],"readingTime":0.8433333333333334,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"one-wire-protocol","title":"Comment marche le bus 1-Wire ?","tags":["bus","1-wire"],"unlisted":true,"authors":"mrvym","hide_title":false},"unlisted":false,"prevItem":{"title":"Sleep from Python to Electronics","permalink":"/sleep-from-python-to-electronics"},"nextItem":{"title":"How copy-paste works on Linux ?","permalink":"/how-copy-paste-works-on-linux"}},"content":"Dans cet article, nous allons voir comment marche un bus un peu particulier. \nLe 1-Wire, le concept est simple. Un seul fil pour communiquer entre le `Master` et le `Slave`.\n\n## Point Histoire\n\nTODO\n\n<!-- truncate --> \n## Allo, il y a quelqu'un ?\n\n> Non, y a personne :wink:\n\nOn appelle ce genre de bus, des bus Half-Duplex. \nUn bus half-duplex, cela veut dire que les deux entités peuvent parler sur le bus mais pas de maniere simultané. \n\n### Cablage\n\nLes appareils qui utilisent le bus `1-Wire` ont trés souvent : \n- Pin 1 -> DATA\n- Pin 2 -> VCC \n- Pin 3 -> GND\n\n![1 Wire Cablage](./1-Wire-Cablage.png)\n\nIl faut savoir que certains equipements peuvent etre alimentés via le fil de `DATA` car l'etat du bus par défaut est \"HIGH\".\nLa norme fait en sorte que les mise a l'etat bas (0V) soit inferieurs a 60ms. \nIl suffit donc d'avoir un condensateur de decoupage au niveau de l'alimentation pour liser la tension.\n\n## Au debut du commencement\n\nAfin de lancer la communication, le `Master` doit se mettre a l'etat bas (0V) pendant plus de 480µs. Apres cela, le `Slave` devra a son tour mettre a l'etat bas le fil de Data pendant 60µs.\n\n![1 Wire Reset / SOF](./1-Wire-Reset.png)\n\n## Master to Slave\n\n- Envoi 0\n- Envoi 1\n\n### POV Slave\n\n## Slave to Master \n\n- Envoi 0\n- Envoi 1\n\n### POV Slave \n \n\n## 1-Wire with UART \n\nTODO\n\n## Conclusion\n- Limitation Technique\n- Interet \n\nSources :\n- [Domadoo Guide](https://blog.domadoo.fr/guides/principe-du-protocole-1-wire/)"},{"id":"how-copy-paste-works-on-linux","metadata":{"permalink":"/how-copy-paste-works-on-linux","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2025-01-31-How-copy-paste-works.mdx","source":"@site/blog/2025-01-31-How-copy-paste-works.mdx","title":"How copy-paste works on Linux ?","description":"In this article, we will explore the internal functioning of Copy-Paste in Linux.","date":"2025-01-31T00:00:00.000Z","tags":[{"inline":true,"label":"Linux","permalink":"/tags/linux"},{"inline":true,"label":"Xorg","permalink":"/tags/xorg"},{"inline":true,"label":"Copy","permalink":"/tags/copy"},{"inline":true,"label":"Paste","permalink":"/tags/paste"}],"readingTime":0.7533333333333333,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"how-copy-paste-works-on-linux","title":"How copy-paste works on Linux ?","tags":["Linux","Xorg","Copy","Paste"],"hide_title":false,"date":"2025-01-31T00:00:00.000Z","unlisted":true,"authors":["mrvym"]},"unlisted":false,"prevItem":{"title":"Comment marche le bus 1-Wire ?","permalink":"/one-wire-protocol"},"nextItem":{"title":"Le plus petit segfault","permalink":"/le-plus-petit-segfault"}},"content":"In this article, we will explore the internal functioning of Copy-Paste in Linux. \nFirst, let me introduce some context. There is a manual, almost like an RFC. \n\nThe Inter-Communication Client Conventions Manual (for short ICCCM), which imposes some rules. \nThe first version was published in July 1989 and the second in 1994. \nThis manual, written 30 years ago, is therefore the reference for the subject.  \n\n<!-- truncate -->\n\n## X10 and cut-buffers\n\nFor context, first release of X10 was in 1985. At this time, the ICCCM wasn't released.\nXorg made it's own custom way to works. They used a thing called `cut-buffer` or also knows as `buffer-cut`.\n\nA cut-buffer works like a circular buffer of 8 buffers, which begins from CUTBUFFER0 to CUTBUFFER7.\nWhen a user want add a string in a cut-buffer, every string switches to another buffer. \nSo the circular buffer is like a history of all copy-paste.\n\nNowday, there is no more programs which used a cut-buffer or at least they used the cut-buffer and the new way.\n\n\n## Support by X11 \n\n### Selection\n#### PRIMARY\n#### SECONDARY\n  - Unused\n#### CLIPBOARD\n\n## Support by Tmux\n\n## Alias\n\n```sh\nalias paste=\"xsel --clipboard\"\n```\n\n```sh\nalias copy=\"xsel --clipboard\"\n```\nSources : \n- [ICCCM](https://x.org/releases/X11R7.6/doc/xorg-docs/specs/ICCCM/icccm.html)\n- [VimDoc](http://vimdoc.sourceforge.net/htmldoc/gui_x11.html#quoteplus)\n- [ClipbordWiki](https://www.freedesktop.org/wiki/Specifications/ClipboardsWiki/)\n- [StackOverflow - Diff between X Clip](https://superuser.com/questions/90257/what-is-the-difference-between-the-x-clipboards)"},{"id":"le-plus-petit-segfault","metadata":{"permalink":"/le-plus-petit-segfault","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2025-01-17-petit-segfault/index.md","source":"@site/blog/2025-01-17-petit-segfault/index.md","title":"Le plus petit segfault","description":"Coder le plus petit segfault du monde ! Et creusez dans le fonctionnement du 'main'.","date":"2025-01-17T00:00:00.000Z","tags":[{"inline":false,"label":"C Language","permalink":"/tags/c","description":"The most wonderful language"},{"inline":true,"label":"segv","permalink":"/tags/segv"}],"readingTime":7.619999999999999,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"le-plus-petit-segfault","title":"Le plus petit segfault","description":"Coder le plus petit segfault du monde ! Et creusez dans le fonctionnement du 'main'.","tags":["C","segv"],"hide_title":false,"authors":["mrvym"]},"unlisted":false,"prevItem":{"title":"How copy-paste works on Linux ?","permalink":"/how-copy-paste-works-on-linux"},"nextItem":{"title":"Tester c'est tricher, compiler c'est douter","permalink":"/tester-cest-tricher-compiler-c-est-douter"}},"content":"Dans cet article, on va voir comment créer un code qui crash le plus efficacement possible.  \nCela veut dire comprendre ce qu'est un segfault, comment marche la fonction `main`, ainsi que le code exécuté avant.\n\nUne magnifique occasion de faire de l'assembleur !\n\n<!-- truncate --> \n### Sans plus attendre, voici notre premier exemple :\n\n```c\nmain;\n```\n\nCe code compile très bien :  \n> `gcc main.c -o main`\n\net produit cet output :\n\n```sh\n$ ./main\n[1]    20677 segmentation fault (core dumped)  ./main\n```\n\n\n### Un segfault\n\nJe pense que c’est le bon moment pour répondre à cette question : c’est quoi un segfault ?  \n\nUn **segfault** ou \"segmentation fault\" est une erreur de segmentation. On l’obtient lorsque notre programme essaye de lire un pointeur qui ne nous appartient pas.  \nAu lancement du programme, l’OS lui attribue une certaine quantité de mémoire, et il n’a pas le droit d’en sortir.\n\nC’est une sécurité pour empêcher des programmes d’accéder à des zones mémoire non autorisées.\n\nQuand l’OS (ou plus précisément, le MMU) détecte que le programme tente d’accéder à une mémoire non autorisée, il génère cette \"fault\".\n\n\n### On dump des objets\n\nPour mieux comprendre le fonctionnement du programme, on va aller voir le code machine.  \nLe flag `-t` nous permet de récupérer juste la liste des symboles :  \n\n```sh\n$ objdump -t ./main\n# <-- truncate --> \n0000000000004000  w      .data\t0000000000000000              data_start\n0000000000004000 g       .data\t0000000000000000              __data_start\n0000000000001020 g     F .text\t0000000000000026              _start\n0000000000004010 g       .bss\t0000000000000000              __bss_start\n0000000000004014 g     O .bss\t0000000000000004              main\n# <-- truncate --> \n0000000000001000 g     F .init\t0000000000000000              .hidden _init\n```\n\nOn remarque que le symbole `main` est dans le segment `.bss` et pas dans `.text`.\n\n![Segments in ELF file](./segment-c-code.png)\n\n#### Segment **bss** :  \n> Le segment `.bss` (Block Starting Symbol) contient les variables statiques allouées.  \n\n#### Segment **text** :  \n> Le segment `.text` contient les instructions exécutables du programme.\n\n\nOn se rend compte que notre code ne déclare pas une fonction, mais bien une variable. La variable étant globale, le compilateur crée un symbole pour elle.  \nCela se vérifie très simplement en rajoutant une variable `test` dans notre code :  \n\n```sh\n0000000000004018 g     O .bss\t0000000000000004              test\n```\n\nEn effet, le nom `main` n’est pas un keyword spécifique en C. C’est juste un nom de fonction arbitraire qui est appelé au lancement du programme.\n\n\n### Pour les Québécois\n\nPour les puristes d’entre vous, il est tout à fait possible de ne pas inclure une fonction `main` dans votre code.  \nIl suffit d’écrire votre propre fonction `_start` et de demander à GCC de ne pas linker la sienne :\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint principale() {\n  puts(\"Hey là, ça marche-tu?\");\n  return 0;\n}\n\nvoid _start() {\n  int ret = principale();\n  exit(ret);\n}\n```\n\n> `$ gcc principale.c -o principale -nostartfiles`\n\n\n### Lancement du programme\n\nMais au fait, qui call la fonction `main` ?\n\nPour répondre à cette question, regardons le code assembleur de notre programme, en particulier la fonction `_start`.  \nAu passage, on remarque que son symbole est bien dans le segment `.text`.\n\nVoici une version simplifiée du code (la fonction complète est assez complexe) :\n\n```asm\n_start: \n    xor %ebp, %ebp            \n    mov (%rsp), %edi          \n    lea 8(%rsp), %rsi         \n    lea 16(%rsp,%rdi,8), %rdx \n    xor %eax, %eax            \n    call main                 \n\n    mov %eax, %edi    \n    xor %eax, %eax   \n    call _exit      \n```\n\n#### Étapes de `_start` :\n- On marque la fin de la stack frame :  \n    `xor %ebp, %ebp`  \n- On initialise `argc` :  \n    `mov (%rsp), %edi`  \n- On initialise `argv` :  \n    `lea 8(%rsp), %rsi`  \n- On initialise `envp` :  \n    `lea 16(%rsp,%rdi,8), %rdx`  \n- On set un code retour initialisé à 0 (compatibilité) :  \n    `xor %eax, %eax`  \n- On call `main(argc, argv, envp)` :  \n    `call main`  \n- On call la fonction `_exit` avec le code retour :  \n    `mov %eax, %edi`  \n    `call _exit`\n\n### Envp ??\n\nLe vrai prototype de la fonction `main` a 3 arguments :  \n\n```c\nint main(int argc, char* argv[], char* envp[]);\n```\n\n> Oui, j’ai découvert le vrai prototype en analysant le reverse de `_start`.\n\nComme son nom l’indique, `envp` correspond aux variables d’environnement du shell.  \nSi on ne vous a jamais montré ça, c’est parce que ce n’est pas portable (même si toutes les machines actuelles le supportent).\n\n\n### Encore plus petit\n\nEt oui, si vous avez bien suivi, il est maintenant possible de segfault encore plus vite. Il suffit que le segfault soit directement dans la fonction `_start`, sans passer par `main`.  \n\nVoici un exemple minimaliste (vide) :  \n\n```sh\n$ touch main.c\n/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000001000\n$ gcc -o main main.c -nostartfiles\n```\n\nNous avons certes un warning, mais ça compile.  \nUn `objdump` montre qu’il n’y a presque rien dans ce fichier et que le symbole `_start` n’est pas défini :\n\n```sh\n$ objdump -t ./main\n<-- truncate --> \n0000000000000000         *UND*\t0000000000000000 _start\n```\n## Scrt1.o, ça sort d'où ?\n\nAlors hormis le fait que j'ai lu la doc de GCC, comment est-ce que je sais que `Scrt1.o` existe ?  \nVous connaissez le `-v` ? Eh oui, on peut très bien activer le debug / verbose sur GCC.  \n\nPersonne ne le fait parce qu'il faut avoir un sacré melon pour considérer que GCC fait mal son travail (sauf moi).  \n\nEn activant ce flag, on se retrouve avec pas mal de variables d'env qui sont print, mais pas que. On trouve notamment cette ligne dans laquelle on voit l'include des fichiers `.o` :  \n\n```sh\n/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/collect2 \n    -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/liblto_plugin.so \n    -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/lto-wrapper \n    -plugin-opt=-fresolution=/tmp/ccEcycpv.res \n    -plugin-opt=-pass-through=-lgcc \n    -plugin-opt=-pass-through=-lgcc_s \n    -plugin-opt=-pass-through=-lc \n    -plugin-opt=-pass-through=-lgcc \n    -plugin-opt=-pass-through=-lgcc_s \n    --build-id --eh-frame-hdr --hash-style=gnu \n    -m elf_x86_64 \n    -dynamic-linker /lib64/ld-linux-x86-64.so.2 \n    -pie -o main \n    /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/Scrt1.o \n    /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/crti.o \n    /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/crtbeginS.o \n    -L/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1 \n    -L/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib -L/lib/../lib -L/usr/lib/../lib \n    -L/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../.. /tmp/cciOyF1Z.o \n    -lgcc \n    --push-state \n    --as-needed \n    -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s \n    --pop-state /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/crtendS.o \n    /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/crtn.o\n```\n\nOn remarque beaucoup de flags, on peut essayer d'analyser rapidement leur effet.  \n\n- Les amateurs de CTF, vous aurez remarqué le flag `-pie`, qui permet d'activer l'Address Space Layout Randomization (ASLR).  \n- `-lgcc` : eh oui, votre programme C compile avec la librairie dynamique GCC.  \n  Vous pouvez éviter ça en compilant avec `-nostdlib`. Je ne vois pas bien l'intérêt, mais c'est un choix.  \n- `-m elf_x86_64` : c'est ici que GCC spécifie l'architecture de la machine cible.  \n  C'est possible de modifier cette machine cible, cela s'appelle la cross compilation (mais j'en ferai un article spécifique).  \n\nOn trouve aussi le fichier `Scrt1.o`, qui contient le point d'entrée (`_start`) de l'exécutable. Les fichiers `crti.o` et `crtbeginS.o`, eux, fournissent des routines nécessaires à l’initialisation des fonctions globales et statiques.  \nOn pourra citer les fonctions `_init` et `_fini`.  \n\n\nSource : \n- [The C Runtime Initialization, crt0.o](https://www.embecosm.com/appnotes/ean9/html/ch05s02.html)\n- [Linux Questions - Forums](https://www.linuxquestions.org/questions/programming-9/_start-_init-and-frame_dummy-functions-810257/)\n- [Stackoverflow - _start in C](https://stackoverflow.com/questions/29694564/what-is-the-use-of-start-in-c)\n\n### Bonus\n\nPour les **chads** ! Voici le code complet de la fonction `_start`.\n\n<details>\n```asm\n0000000000001020 <_start>:\n    1020:\tf3 0f 1e fa          \tendbr64\n    1024:\t31 ed                \txor    %ebp,%ebp\n    1026:\t49 89 d1             \tmov    %rdx,%r9\n    1029:\t5e                   \tpop    %rsi\n    102a:\t48 89 e2             \tmov    %rsp,%rdx\n    102d:\t48 83 e4 f0          \tand    $0xfffffffffffffff0,%rsp\n    1031:\t50                   \tpush   %rax\n    1032:\t54                   \tpush   %rsp\n    1033:\t45 31 c0             \txor    %r8d,%r8d\n    1036:\t31 c9                \txor    %ecx,%ecx\n    1038:\t48 8d 3d d5 2f 00 00 \tlea    0x2fd5(%rip),%rdi        # 4014 <main>\n    103f:\tff 15 7b 2f 00 00    \tcall   *0x2f7b(%rip)        # 3fc0 <__libc_start_main@GLIBC_2.34>\n    1045:\tf4                   \thlt\n    1046:\t66 2e 0f 1f 84 00 00 \tcs nopw 0x0(%rax,%rax,1)\n    104d:\t00 00 00\n    1050:\t48 8d 3d b9 2f 00 00 \tlea    0x2fb9(%rip),%rdi        # 4010 <__TMC_END__>\n    1057:\t48 8d 05 b2 2f 00 00 \tlea    0x2fb2(%rip),%rax        # 4010 <__TMC_END__>\n    105e:\t48 39 f8             \tcmp    %rdi,%rax\n    1061:\t74 15                \tje     1078 <_start+0x58>\n    1063:\t48 8b 05 5e 2f 00 00 \tmov    0x2f5e(%rip),%rax        # 3fc8 <_ITM_deregisterTMCloneTable@Base>\n    106a:\t48 85 c0             \ttest   %rax,%rax\n    106d:\t74 09                \tje     1078 <_start+0x58>\n    106f:\tff e0                \tjmp    *%rax\n    1071:\t0f 1f 80 00 00 00 00 \tnopl   0x0(%rax)\n    1078:\tc3                   \tret\n    1079:\t0f 1f 80 00 00 00 00 \tnopl   0x0(%rax)\n    1080:\t48 8d 3d 89 2f 00 00 \tlea    0x2f89(%rip),%rdi        # 4010 <__TMC_END__>\n    1087:\t48 8d 35 82 2f 00 00 \tlea    0x2f82(%rip),%rsi        # 4010 <__TMC_END__>\n    108e:\t48 29 fe             \tsub    %rdi,%rsi\n    1091:\t48 89 f0             \tmov    %rsi,%rax\n    1094:\t48 c1 ee 3f          \tshr    $0x3f,%rsi\n    1098:\t48 c1 f8 03          \tsar    $0x3,%rax\n    109c:\t48 01 c6             \tadd    %rax,%rsi\n    109f:\t48 d1 fe             \tsar    $1,%rsi\n    10a2:\t74 14                \tje     10b8 <_start+0x98>\n    10a4:\t48 8b 05 2d 2f 00 00 \tmov    0x2f2d(%rip),%rax        # 3fd8 <_ITM_registerTMCloneTable@Base>\n    10ab:\t48 85 c0             \ttest   %rax,%rax\n    10ae:\t74 08                \tje     10b8 <_start+0x98>\n    10b0:\tff e0                \tjmp    *%rax\n    10b2:\t66 0f 1f 44 00 00    \tnopw   0x0(%rax,%rax,1)\n    10b8:\tc3                   \tret\n    10b9:\t0f 1f 80 00 00 00 00 \tnopl   0x0(%rax)\n    10c0:\tf3 0f 1e fa          \tendbr64\n    10c4:\t80 3d 45 2f 00 00 00 \tcmpb   $0x0,0x2f45(%rip)        # 4010 <__TMC_END__>\n    10cb:\t75 33                \tjne    1100 <_start+0xe0>\n    10cd:\t55                   \tpush   %rbp\n    10ce:\t48 83 3d 0a 2f 00 00 \tcmpq   $0x0,0x2f0a(%rip)        # 3fe0 <__cxa_finalize@GLIBC_2.2.5>\n    10d5:\t00\n    10d6:\t48 89 e5             \tmov    %rsp,%rbp\n    10d9:\t74 0d                \tje     10e8 <_start+0xc8>\n    10db:\t48 8b 3d 26 2f 00 00 \tmov    0x2f26(%rip),%rdi        # 4008 <__dso_handle>\n    10e2:\tff 15 f8 2e 00 00    \tcall   *0x2ef8(%rip)        # 3fe0 <__cxa_finalize@GLIBC_2.2.5>\n    10e8:\te8 63 ff ff ff       \tcall   1050 <_start+0x30>\n    10ed:\tc6 05 1c 2f 00 00 01 \tmovb   $0x1,0x2f1c(%rip)        # 4010 <__TMC_END__>\n    10f4:\t5d                   \tpop    %rbp\n    10f5:\tc3                   \tret\n    10f6:\t66 2e 0f 1f 84 00 00 \tcs nopw 0x0(%rax,%rax,1)\n    10fd:\t00 00 00\n    1100:\tc3                   \tret\n    1101:\t66 66 2e 0f 1f 84 00 \tdata16 cs nopw 0x0(%rax,%rax,1)\n    1108:\t00 00 00 00\n    110c:\t0f 1f 40 00          \tnopl   0x0(%rax)\n    1110:\tf3 0f 1e fa          \tendbr64\n    1114:\te9 67 ff ff ff       \tjmp    1080 <_start+0x60>\n```\n</details>"},{"id":"tester-cest-tricher-compiler-c-est-douter","metadata":{"permalink":"/tester-cest-tricher-compiler-c-est-douter","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2025-01-10-Tester-cest-tricher/index.md","source":"@site/blog/2025-01-10-Tester-cest-tricher/index.md","title":"Tester c'est tricher, compiler c'est douter","description":"Dans cet article, nous allons voir le concept de Continuous Integration (CI), son intérêt et ses inconvénients et une démonstration.","date":"2025-01-10T00:00:00.000Z","tags":[{"inline":true,"label":"git","permalink":"/tags/git"},{"inline":true,"label":"CI","permalink":"/tags/ci"},{"inline":false,"label":"C Language","permalink":"/tags/c","description":"The most wonderful language"}],"readingTime":3.786666666666666,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"title":"Tester c'est tricher, compiler c'est douter","slug":"tester-cest-tricher-compiler-c-est-douter","tags":["git","CI","C"],"hide_title":false,"date":"2025-01-10T00:00:00.000Z","authors":["mrvym"]},"unlisted":false,"prevItem":{"title":"Le plus petit segfault","permalink":"/le-plus-petit-segfault"},"nextItem":{"title":"Introduction à Terraform avec Proxmox","permalink":"/intro-terraform-proxmox"}},"content":"Dans cet article, nous allons voir le concept de Continuous Integration (CI), son intérêt et ses inconvénients et une démonstration.\n\n## Histoire\n\nMais d'abord, comme à mon habitude, un petit point histoire.\n\n> En 1999, Kent Beck a approfondi le sujet dans son premier livre sur l'Extreme Programming. En 2001, CruiseControl, l'un des premiers outils open-source de CI, a vu le jour.\n<!-- truncate --> \n## Mais why ?  \nLe but d'une CI est de faire des tests automatisés à chaque commit. Cela garantit que le code reste fonctionnel en permanence. On appelle cela une Continuous Integration car, à chaque modification, le code est vérifié pour s'assurer qu'il n'y a pas de régressions.\n\n### Avantages\n\n- **Détection précoce des erreurs** : Les problèmes sont identifiés rapidement, ce qui permet de réagir sans attendre.  \n- **Amélioration de la qualité** : En testant systématiquement, on garantit un code plus robuste.  \n- **Gain de temps** : Les pipelines automatisés réduisent la nécessité de tests manuels répétitifs.\n\n### Inconvénients\n\n- **Coût initial** : Mettre en place une CI peut demander des efforts et des compétences initiales importantes.  \n- **Temps d’exécution** : Les pipelines complexes peuvent rallonger le temps avant qu'un développeur puisse valider son code.\n\n## Fonctionnement\n\nAvant de voir le fonctionnement, un petit lexique :  \n\n- **Jobs** : Une instance d'un conteneur (souvent Docker) qui exécute un script. Cela peut inclure des commandes, des tests ou des actions simples comme un `echo`.  \n- **Pipeline** : Une série de jobs organisés de manière séquentielle ou parallèle. Chaque commit déclenche cette série pour valider les changements.  \n\nLe principe est simple : chaque job retourne un code de statut (succès ou échec). Si un job échoue, la pipeline s’arrête ou ignore les étapes suivantes selon la configuration.\n\n## Trêve de blabla\n\nNous allons utiliser un exemple basé sur GitLab CI. On la configure via un fichier `.gitlab-ci.yml`.\n\n### Basique, simple, simple, basique\n\n```yaml\nimage: bookworm-slim:latest\n\nmyjobname:\n  script:\n    - make\n```\n\n### Les flags\n\nPour ajouter des flags de compilation, deux approches sont possibles :  \n\n1. Via une règle dans le Makefile.  \n2. En passant les flags directement dans la commande CI.  \n\n```yaml\nmyjobname_hard:\n  script:\n    - CFLAGS=\"-Wall -Werror\" make\n    # ou\n    - make compile_flags\n```\n\n### Tests avec Criterion et flags\n\nCriterion est une bibliothèque de tests unitaires en C.\n\n#### Où est passé Criterion ?  \n\nAvant d’exécuter des tests avec Criterion, il est souvent nécessaire d'installer Criterion, eh oui !\n\n```yaml\nbefore_script:\n  - apt-get update && apt-get install -y libcriterion-dev\nscript:\n  - ./configure\n  - make test\n```\n\n#### Multistaging\nDiviser les tests unitaires et fonctionnels en plusieurs stages garantit :  \n- une bonne organisation  \n- une meilleure visibilité des résultats  \n\n```yaml\nstages:\n  - build\n  - test\n\nbuild:\n  stage: build\n  script:\n    - make all\n\ntest-unit:\n  stage: test\n  script:\n    - make unit-test\n\ntest-functional:\n  stage: test\n  script:\n    - make functional-test\n```\n\n### Tu t'es fait clang ?  \n\nLe formatage du code est super important pour maintenir une base de code propre.  \n\n```yaml\nclang_format:\n  stage: format\n  before_script:\n    - apt-get -qq update && apt-get -qq install -y clang-format autotools-dev autoconf-archive gcovr libcriterion-dev\n  script:\n    - clang-format -i $(find src/ -type f -name \"*.c\") --dry-run --Werror\n```\n\n### Cache\n\nDans certains cas, c'est utile de mettre en cache des fichiers ou dossiers pour éviter de les recharger à chaque pipeline.  \nUn exemple courant est le dossier `node_modules/` en JavaScript.\n\n```yaml\ncache:\n  paths:\n    - node_modules/\n\ninstall:\n  script:\n    - npm install\n```\n\nBien entendu, vous pouvez nettoyer le cache au besoin avec une option supplémentaire dans la configuration de pipeline.\n\n### Artefacts\n\nLes artefacts sont les fichiers générés par la CI qui peuvent être partagés entre jobs ou téléchargés.  \nPar exemple, les rapports de tests ou de couverture.\n\n```yaml\nartifacts:\n  paths:\n    - build/\n    - reports/\n```\n\n### Coverage de tests\n\nOn peut mesurer la couverture de tests en intégrant des outils comme gcovr ou Cobertura dans votre pipeline CI.\n\n```yaml\ntest-coverage:\n  stage: test\n  script:\n    - gcovr --html --html-details -o coverage.html\n  artifacts:\n    paths:\n      - coverage.html\n```\n\n#### Rapporteur\n\nCe bloc vous permet d'intégrer le coverage report dans votre Merge Request, vous pourrez ainsi voir le code qui n'est pas couvert mais aussi votre pourcentage de coverage. \n\n```yaml\ncoverage-report:\n  script:\n    # do coverage\n  coverage: /^TOTAL.*\\s+(\\d+\\%)$/\n  artifacts:\n    name: coverage.xml\n    expire_in: 2 days\n    reports:\n      coverage_report:\n        coverage_format: cobertura\n        path: coverage.xml\n\n```\n### Environnement custom  \n\nVous pouvez préciser l’environnement de base pour votre CI en sélectionnant une image Docker spécifique.\n\n```yaml\nimage: gcc:latest\n```\n\nEn utilisant un peu ce que l'on vient de voir, ça donnerait quelque chose comme ça :  \n\n```yaml\nimage: gcc\n\nstages:\n  - format\n  - build\n  - test\n  - clean\n\nclang-format:\n  stage: format\n  script:\n    - clang-format -i $(find src/ -type f -name \"*.c\") --dry-run --Werror\n\nbuild:\n  stage: build\n  script:\n    - autoreconf --install\n    - ./configure\n    - make all\n\ntest-unit:\n  stage: test\n  script:\n    - autoreconf --install\n    - ./configure\n    - make unit-test\n```\n\n> Attention aux `.h` et il manque des `before_script`.\n\n### Petit Bonus  \n\nOn peut aussi vérifier les trash-files pour s’assurer que le `make clean` fait bien son travail.\n\n```yaml\ntrash-file:\n  stage: clean\n  needs: []\n  before_script:\n    - apt-get -qq update && apt-get -qq install -y tree\n  script:\n    - tree > /tmp/REF\n    - make && make clean\n    - tree > /tmp/TEST\n    - diff /tmp/REF /tmp/TEST\n```\n\n## Conclusion\n\nLa Continuous Integration est un outil extrêmement puissant. Il peut parfois être difficile à mettre en place, mais les gains sont immenses."},{"id":"intro-terraform-proxmox","metadata":{"permalink":"/intro-terraform-proxmox","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2024-12-02-intro-terraform-proxmox.md","source":"@site/blog/2024-12-02-intro-terraform-proxmox.md","title":"Introduction à Terraform avec Proxmox","description":"Le but de Terraform est de déployer une infrastructure ou une entité de manière idempotente. Cela signifie que l’on doit pouvoir relancer le script 100 fois et obtenir le même résultat à chaque exécution.","date":"2024-12-02T00:00:00.000Z","tags":[{"inline":true,"label":"terraform","permalink":"/tags/terraform"},{"inline":true,"label":"proxmox","permalink":"/tags/proxmox"},{"inline":false,"label":"devops","permalink":"/tags/devops","description":"DevOps - Tools"},{"inline":true,"label":"hcl","permalink":"/tags/hcl"},{"inline":true,"label":"BPG","permalink":"/tags/bpg"}],"readingTime":4.826666666666666,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"intro-terraform-proxmox","title":"Introduction à Terraform avec Proxmox","tags":["terraform","proxmox","devops","hcl","BPG"],"authors":["mrvym"],"hide_title":false,"date":"2024-12-02T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Tester c'est tricher, compiler c'est douter","permalink":"/tester-cest-tricher-compiler-c-est-douter"},"nextItem":{"title":"Disque dur : SAS, SATA, SCSI ou IDE ?","permalink":"/disque-dur-sas-sata-scsi-ide"}},"content":"Le but de Terraform est de déployer une infrastructure ou une entité de manière **idempotente**. Cela signifie que l’on doit pouvoir relancer le script 100 fois et obtenir le même résultat à chaque exécution.  \nPour cela, nous utilisons un **provider**, qui est essentiellement une bibliothèque permettant de se connecter à notre serveur.\n\nDans ce cas pratique, nous allons utiliser **Proxmox** et **BPG**. Il existe deux principaux providers pour Proxmox :\n\n- **[Telmate](https://registry.terraform.io/providers/Telmate/proxmox/latest/docs)**  \n  C’est une bibliothèque qui permet de déployer très simplement des VMs et des LXCs.  \n  Inconvénient : elle n’implémente pas de fonctionnalités avancées. Cependant, elle est fréquemment mise à jour.\n  \n- **[Bpg](https://registry.terraform.io/providers/bpg/proxmox/latest/docs)**  \n  Cette bibliothèque est légèrement plus complexe à prendre en main, mais elle est bien plus puissante.\n\n<!-- truncate --> \n## Organisation et Structure d'un Projet Terraform \n\nAfin que vous puissiez mieux comprendre le projet, voici son architecture :\n\n```sh\n├── main.tf\n├── provider.tf\n├── variable.tf\n└── terraform.auto.tfvars\n```\n\nVous pouvez ajouter ou segmenter le projet en autant de fichiers `.tf` que nécessaire. Par exemple, nous aurions pu avoir un fichier pour les VMs et un autre pour les LXCs.\n\n- Les fichiers se terminant par `.tfvars` servent à définir des variables. Lorsqu’ils commencent par `auto`, ils sont automatiquement chargés par Terraform.  \n- Le fichier `variable.tf` permet de créer des variables sans les instancier.\n\n### Petit point Vocabulaire\nDans cette article, nous allons utiliser le terme de LXC et de VM. Je vais faire un petit point dessus.\n\n- **`LXC`** ou **`LinuX Container`** : ce sont des environnements virtualisés qui tourne sur le `kernel` de l'hôte mais qui ne peuvent pas discuter ensemble. Cela permet de segmenter nos services sans trop perde en performance.\n\n- **`VM`** ou **`Virtual Machine`** : comme son nom l'indique, on simule l'intégralité d'une machine. On perd en performance mais on gagne en sécurité et en fonctionnalité car un LXC n'a pas tout les privilèges.\n\n## Choisir et Configurer un Provider Proxmox\n\nAvant tout, nous devons installer le **provider** (la bibliothèque). Bien entendu, nous fixons une version minimale :  \n\n```hcl\nterraform {\n  required_providers {\n    proxmox = {\n      source  = \"bpg/proxmox\"\n      version = \">= 0.3.0\"\n    }\n  }\n  required_version = \">= 0.14\"\n}\n```\n\nUne fois la bibliothèque ajoutée, nous déclarons un provider nommé \"proxmox\", en fournissant les informations nécessaires :  \n\n```hcl\nprovider \"proxmox\" {\n  endpoint = \"https://${var.proxmox_endpoint}:8006\"\n  api_token = var.api_token_secret\n\n  insecure = true # car un certificat TLS auto-signé est utilisé\n  ssh {\n    agent = true\n    username = terraform\n  }\n}\n```\n\n---\n\n## Les Variables dans Terraform\n\nSi vous êtes attentif, vous avez remarqué que nous utilisons l’objet `var.api_token_secret` dans le bloc du provider. Cette chaîne de caractères est définie dans le fichier `terraform.auto.tfvars`.  \n\nÀ la manière d’un fichier `.env`, ce fichier contient des valeurs sensibles et **ne doit pas être poussé sur le dépôt git** :  \n\n```hcl\n# terraform.auto.tfvars\napi_token_secret = \"terraform-prov@pve!terraform=TOKEN\"\n```\n\nDans le fichier `variable.tf`, nous définissons les variables et leur type.  \nVoici les principaux types disponibles :  \n\n- **number**\n- **string**\n- **list()** (ex. : `list(string)`)\n- **object**\n- **map**\n\nExemple :  \n\n```hcl\n# variable.tf\n\nvariable \"api_token_secret\" {\n  description = \"Secret token to connect Proxmox API\"\n  type        = string\n}\n\nvariable \"proxmox_endpoint\" {\n  description = \"The domain name of the Proxmox instance\"\n  type        = string\n  default     = \"proxmox.mysite.fr\"\n}\n```\n\n---\n\n## Les Images et les Templates\n\nPour démarrer nos entités, nous devons leur fournir un système d’exploitation.  \nNous téléchargeons automatiquement un fichier de template pour le LXC et un ISO avec **cloud-init** pour la VM.  \n\n> Si vous ne connaissez pas **cloud-init**, c’est une méthode permettant d’instancier des machines sans passer par l’installateur de l’OS.  \n\n```hcl\nresource \"proxmox_virtual_environment_download_file\" \"ubuntu_22-04_lxc\" {\n  content_type = \"vztmpl\"\n  datastore_id = \"local\"\n  node_name    = var.target_node\n  url          = \"http://download.proxmox.com/images/system/ubuntu-22.04-standard_22.04-1_amd64.tar.zst\"\n}\n\nresource \"proxmox_virtual_environment_download_file\" \"ubuntu_22-04_img\" {\n  content_type = \"iso\"\n  datastore_id = \"local\"\n  node_name    = var.target_node\n  url          = \"https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img\"\n}\n```\n\n---\n\n## On crée un Réseau Virtuel\nSi nous avons envie que nos ressources discutent entre elles, il nous faut un réseau.\n\nPour créer un adaptateur virtuel, il suffit d’appeler la ressource `proxmox_virtual_environment_network_linux_bridge` et de lui donner un nom :  \n\n```hcl\nresource \"proxmox_virtual_environment_network_linux_bridge\" \"internal_network\" {\n  node_name = var.target_node\n  name      = \"vmbr5\"\n  comment   = \"Internal Network\"\n}\n```\n\n---\n\n## Votre premier Container  \n\nPassons aux choses concrètes en instanciant un **LXC**. Pour cela, nous créons une ressource `proxmox_virtual_environment_container`.  \n\nAvec l’IaC, tout peut être configuré : le disque, la RAM, le serveur DNS, etc.  \n\n```hcl\nresource \"proxmox_virtual_environment_container\" \"first_lxc\" {\n  description   = \"Managed by Terraform - Mr.VyM\"\n  node_name     = var.target_node\n  start_on_boot = true\n  started       = true\n\n  vm_id = 101\n\n  cpu {\n    architecture = \"amd64\"\n    cores        = var.core_nb\n  }\n\n  disk {\n    datastore_id = \"storage\"\n    size         = var.disk_size\n  }\n\n  memory {\n    dedicated = var.memory_size\n    swap      = 0\n  }\n\n  operating_system {\n    template_file_id = proxmox_virtual_environment_download_file.ubuntu_22-04_lxc.id\n    type             = \"ubuntu\"\n  }\n\n  initialization {\n    hostname = \"mycontainer\"\n\n    dns {\n      servers = [\"1.1.1.1\", \"1.0.0.1\"]\n    }\n\n    ip_config {\n      ipv4 {\n        address = \"192.168.10.2/24\"\n        gateway = \"192.168.10.1\"\n      }\n    }\n\n    user_account {\n      keys     = [\"keys 1\", \"keys 2\"]\n      password = var.lxc_password\n    }\n  }\n\n  network_interface {\n    bridge = proxmox_virtual_environment_network_linux_bridge.internal_network.name\n    name   = \"eth0\"\n  }\n}\n```\n\n---\n\n## Et maintenant une VM  \n\nCréer une VM suit le même pattern que pour un LXC, avec quelques différences :  \n\n```hcl\nresource \"proxmox_virtual_environment_vm\" \"vm_template\" {\n  description = \"Managed by Terraform - Mr.VyM\"\n  node_name   = var.target_node\n\n  name        = \"MyDummyVM\"\n  vm_id       = 102\n\n  cpu {\n    cores = var.core_nb\n    type  = \"x86-64-v2-AES\"  # recommandé pour les CPU modernes\n  }\n\n  memory {\n    dedicated = var.memory_size\n    floating  = var.memory_size # active le ballooning\n  }\n\n  disk {\n    datastore_id = \"local\"\n    file_id      = proxmox_virtual_environment_download_file.ubuntu_22-04_img.id\n    interface    = \"scsi0\"\n    size         = var.disk_size\n  }\n\n  initialization {\n    ip_config {\n      ipv4 {\n        address = \"${var.base_subnet}.3/24\"\n        gateway = \"${var.base_subnet}.1\"\n      }\n    }\n\n    user_account {\n      keys     = [\"keys 1\", \"keys 2\"]\n      password = var.vm_password \n      username = \"mrvym\"\n    }\n\n    datastore_id = \"local\"\n  }\n\n  network_device {\n    bridge = proxmox_virtual_environment_network_linux_bridge.internal_network.name\n  }\n\n  operating_system {\n    type = \"l26\" # Linux Kernel\n  }\n}\n```\n\n---\n\n## On check et ca part en Prod\n\nEnfin, nous déployons le tout avec les commandes suivantes :  \n\n- **`terraform init`**  \n  Initialise Terraform, télécharge les providers et crée les fichiers `terraform.state` et `terraform.lock`. Ces fichiers stockent l’état des entités sur le serveur.  \n  Si ces fichiers sont absents, Terraform recrée les ressources, ce qui pourrait entraîner leur suppression et recréation.  \n\n- **`terraform fmt`**  \n  Formate le code pour garantir sa propreté.  \n\n- **`terraform plan`**  \n  Vérifie les actions que Terraform s’apprête à exécuter.  \n\n- **`terraform apply`**  \n  Applique les modifications.\n\n\n\n\n\n\n> Ecrit pour l'**`Avent of Tech`** de la [JECT](https://dev.to/ject)"},{"id":"disque-dur-sas-sata-scsi-ide","metadata":{"permalink":"/disque-dur-sas-sata-scsi-ide","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2024-09-07-SAS-or-not-SAS/index.md","source":"@site/blog/2024-09-07-SAS-or-not-SAS/index.md","title":"Disque dur : SAS, SATA, SCSI ou IDE ?","description":"Notre but dans cet article est de mieux comprendre le concept des interfaces matérielles / programmation, des couches physiques et des jeux de commandes, et plus simplement des systèmes de stockage qui nous entourent.","date":"2024-11-07T00:00:00.000Z","tags":[{"inline":true,"label":"SSD","permalink":"/tags/ssd"},{"inline":true,"label":"SAS","permalink":"/tags/sas"},{"inline":true,"label":"Hardware","permalink":"/tags/hardware"},{"inline":true,"label":"Storage","permalink":"/tags/storage"}],"readingTime":4.026666666666666,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"disque-dur-sas-sata-scsi-ide","title":"Disque dur : SAS, SATA, SCSI ou IDE ?","tags":["SSD","SAS","Hardware","Storage"],"hide_title":false,"date":"2024-11-07T00:00:00.000Z","authors":["mrvym"]},"unlisted":false,"prevItem":{"title":"Introduction à Terraform avec Proxmox","permalink":"/intro-terraform-proxmox"},"nextItem":{"title":"#define INC(a) INC(a+1)","permalink":"/define-inc-a-inc-a+1"}},"content":"Notre but dans cet article est de mieux comprendre le concept des interfaces matérielles / programmation, des couches physiques et des jeux de commandes, et plus simplement des systèmes de stockage qui nous entourent.\n\n<!-- truncate --> \nMais d'abord, un \"rapide\" récapitulatif de l'état actuel de nos périphériques de stockage :\n\n| Norme de stockage  | Interface matérielle        | Couche physique                          | Jeux de commandes                  |\n|--------------------|-----------------------------|------------------------------------------|------------------------------------|\n| PATA               | IDE (Integrated Drive Electronics) | Connecteur 40/44 broches, câble parallèle | ACS (ATA Command Set)              |\n| SATA               | SATA (Serial ATA)           | Connecteur SATA, câble série             | ACS (ATA Command Set)              |\n| SAS (Serial Attached SCSI) | SCSI (Small Computer System Interface) | Connecteur SAS, câble série              | SCSI (Small Computer System Interface) |\n| NVMe (Non-Volatile Memory Express) | PCIe (Peripheral Component Interconnect Express) | Bus PCIe | AHCI (Advanced Host Controller Interface) |\n\nSi vous vous demandez, oui, les constructeurs ont pris un malin plaisir à utiliser le même nom entre l'interface et la norme.\n\n--\nAvant de commencer, un point vocabulaire\n> Couche Physique : C'est le cable et le connecteur.\n\n> Interface Materielle : C'est la maniere de communiquer, attention ne pas confondre avec le \"language\". \n\n> Jeu de commandes : C'est le language utilisé.\n\nPour faire une analogie, si vous etes un humain (j'espere :thinking:), la couche physique c'est vos cordes vocales, l'interface materielle, c'est la maniere de faire vibrer vos cordes et le jeu de commandes, c'est le language utilisé. \n\n## Norme de stockage\n\n### ATA \n> Date : 1986  \n> Qui : Western Digital  \n\nATA signifie **Advanced Technology Attachment**.\n\nC'est le véritable concurrent du protocole SCSI. C'est aussi un ensemble de normes avec l'interface matérielle (IDE), la couche physique (PATA ou bien SATA) et les jeux de commandes (ACS).\n\nC'est une version plus low-cost de SCSI, qui avait pour but de réutiliser des éléments de ce dernier mais en simplifiant le connecteur (la couche physique) et le jeu d'instruction.\n\nContrairement au SAS, cette norme est en semi-duplex, ce qui signifie qu'elle ne peut exécuter qu'une seule action simultanément : soit lire, soit écrire.\n\n### SAS \n\n> Date : 1980  \n> Qui : Shugart / NCR Corporation  \n\nC'est un ensemble de normes qui s'applique sur les couches physiques et les jeux de commandes. \n\nNous devons revenir dans les années 80, à cette époque, il n'y a pas des milliers de façons de communiquer avec un périphérique de stockage. L'un d'entre eux est le protocole **SCSI** (Small Computer System Interface).\n\nC'est un protocole propriétaire mais très performant pour son temps. Son grand avantage est le fait de déporter la logique dans le périphérique, contrairement à ses concurrents qui utilisent allègrement la puissance de l'ordinateur. Et dans les années 80, on n'avait pas encore la puissance de calcul, ce protocole a donc été particulièrement apprécié par l'industrie.\n\nDe plus, la norme a l'avantage de pouvoir écrire en duplex, c'est-à-dire lire et écrire des données simultanément.\n\n## Interface matérielle\n\n### IDE\n\nIDE est une norme qui intègre le contrôleur de disque directement sur le disque dur lui-même. Avant IDE, les contrôleurs de disque étaient séparés, ce qui compliquait la configuration et limitait la compatibilité.  \nCela signifie qu'un disque dur est dit compatible IDE s'il possède une puce IDE.\n\n### SATA\n\nC'est une ré-implémentation de l'interface matérielle parallèle en série (Serial ATA).\n\n> Qu'est-ce qu'un port parallèle ?  \n> Contrairement au port série, un port parallèle peut transférer un ensemble de 8 bits à la fois sur huit fils différents.\n\nPour vous donner une idée de l'interface matérielle / couche physique.\n![PATA Pin-out](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/si132dwg6anuqybjfeal.png)\n\n### PCIe\n\nL'interface matérielle PCIe (Peripheral Component Interconnect Express) est une interface de communication utilisée principalement pour connecter des périphériques internes tels que des cartes graphiques, des cartes réseau et d'autres cartes d'extension.\n\nElle utilise un bus série, ce qui signifie que les données sont transmises bit par bit sur une seule ligne, contrairement aux anciennes interfaces parallèles.\n\nPCIe fonctionne avec des connecteurs spécifiques et des voies de transmission (lanes) qui permettent des transferts de données très rapides. \n\nLes cartes PCIe sont insérées dans des slots PCIe sur la carte mère, et l'interface est disponible en différentes versions (x1, x4, x8, x16) en fonction du nombre de voies utilisées, offrant ainsi une bande passante ajustée aux besoins des périphériques.\n\nPCIe est largement utilisé dans les systèmes modernes en raison de sa vitesse de transmission élevée, de sa flexibilité et de sa capacité à évoluer pour prendre en charge des dispositifs nécessitant des débits importants.\n\n## Couche physique\n\nGlobalement, c'est la partie la plus simple de l'article.  \n(Enfin, en électronique, ce n'est jamais simple).\n\nUne couche physique, cela signifie que c'est la norme qui régit la façon de réaliser le câble et le connecteur (cf Illustration du Pin-out)\n\n\n\nUne nappe IDE\n![Nappe IDE](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/fu04kfy2js7vjn27lbpg.jpg)\nDans notre cas, c'est un câble dit \"IDE\".  \nCe genre de câble est la version parallèle, il contient 80 fils, ce qui permet de connecter deux appareils à la carte mère. Le premier sera appelé \"master\" et le deuxième \"slave\".\n\n\n![Master Slave PATA](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/10bq0ctd4sh4ettg1514.png)\nMais je ne vais pas détailler les différents câbles qui existent.\n\n## Jeux de commandes\n\n### ACS (Commandes)\n> Date : années 80  \n> Qui : Shugart / NCR Corporation\n\nLe **ATA Command Set** (ACS) est la liste des commandes que le système peut envoyer au périphérique.  \nOn pourrait citer comme exemples :  \n- WRITE_SECTOR  \n- SLEEP  \n- PACKET  \n- IDENTIFY PACKET DEVICE\n\n### SCSI\n\nACS étant un détournement du jeu de SCSI, on retrouve de grandes similitudes entre les deux jeux. Cependant, on peut les différencier en creusant un peu, notamment en ce qui concerne les rapports d'erreurs.\n\n### AHCI\n\n**AHCI** (Advanced Host Controller Interface) permet une communication optimisée entre le système d'exploitation et les périphériques de stockage, en offrant des fonctionnalités avancées comme le contrôle de file d'attente (pour améliorer les lectures/écritures simultanées) et le mode **NCQ** (Native Command Queuing), qui permet au disque de réorganiser les commandes d'entrée/sortie pour une performance maximale.\n\nCe jeu de commandes facilite également des fonctionnalités telles que la gestion de l'alimentation et le **hot-plug** (permettre l'ajout et le retrait de périphériques sans éteindre le système).\n\nAHCI a été conçu pour améliorer les performances et la gestion des périphériques de stockage SATA en optimisant l'utilisation des ressources et la vitesse des transferts.\n\n# Conclusion / Performance\n\nNous n'avons toujours pas parlé de la partie performance de ces différences, donc voici le mot de la fin.\n\n| Interface    | Vitesse max (Gb/s)       | Type de connexion | Utilisation principale                    |\n|--------------|--------------------------|-------------------|-------------------------------------------|\n| **SATA III** | 6 Gb/s                   | Série            | SSD et HDD domestiques                   |\n| **SAS**      | 22,5 Gb/s                | Série            | Disques professionnels et serveurs       |\n| **PCIe 5.0** | 32 Gb/s par ligne        | Série            | SSD NVMe internes                        |\n| **NVMe**     | Dépend de PCIe           | PCIe             | SSD haute performance                    |\n| **U.2**      | Selon PCIe (16-32 Gb/s)  | PCIe et NVMe     | Serveurs et stations de travail          |\n| **M.2**      | Selon PCIe (16-32 Gb/s)  | PCIe ou SATA     | Ordinateurs portables et de bureau       |\n| **Thunderbolt 3/4** | 40 Gb/s           | Série (USB-C)    | Stockage externe rapide                  |\n| **USB 4**    | 40 Gb/s                  | Série (USB-C)    | Stockage externe polyvalent              |"},{"id":"define-inc-a-inc-a+1","metadata":{"permalink":"/define-inc-a-inc-a+1","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2024-08-17-Define-INC-a/index.md","source":"@site/blog/2024-08-17-Define-INC-a/index.md","title":"#define INC(a) INC(a+1)","description":"Le but de cet article est de vous faire découvrir le magnifique univers des macros en C.","date":"2024-08-17T00:00:00.000Z","tags":[{"inline":true,"label":"define","permalink":"/tags/define"},{"inline":false,"label":"C Language","permalink":"/tags/c","description":"The most wonderful language"},{"inline":true,"label":"macro","permalink":"/tags/macro"}],"readingTime":7.033333333333333,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"define-inc-a-inc-a+1","title":"#define INC(a) INC(a+1)","tags":["define","C","macro"],"hide_title":false,"authors":["mrvym"]},"unlisted":false,"prevItem":{"title":"Disque dur : SAS, SATA, SCSI ou IDE ?","permalink":"/disque-dur-sas-sata-scsi-ide"},"nextItem":{"title":"How to code plot and chart in Docusaurus with MDX","permalink":"/plot-chart-docusaurus-mdx"}},"content":"Le but de cet article est de vous faire découvrir le magnifique univers des macros en C.\n\n# Une directive préprocesseur\nEn C, les lignes qui commencent par un # sont interprétées par le compilateur lors de la compilation des fichiers sources. On les appelle des directives du préprocesseur. Les macros en font partie.\n\nPetit point historique : \n> Les macros en langage C ont été introduites avec la première norme du langage C, appelée ANSI C (ou C89), \n> qui a été standardisée par l'[American National Standards Institute](https://www.ansi.org) (ANSI) en 1989.\n> \n> Cependant, avant cette standardisation, les macros faisaient déjà partie du langage C classique (ou K&R C) utilisé dans les années 1970. \n> Le compilateur C original, développé par Dennis Ritchie pour le système d'exploitation UNIX, incluait déjà une forme rudimentaire de macros via le préprocesseur, permettant des définitions avec #define.\n\n<!-- truncate --> \n# Define \n```c\n#define SENS_DE_LA_VIE 3.14\n\n/* ... */\n\nprintf(\"%f\\n\", SENS_DE_LA_VIE);\n```\nLe `define` a un fonctionnement assez simple à comprendre : le compilateur remplace toutes les occurrences dans le code par la valeur définie. Il fonctionne avec la syntaxe suivante `#define <MACRO_NAME> <value>`. On a pour convention de mettre le nom en majuscule, la valeur quant à elle est optionnelle.\n\nUn peu comme un \"Ctrl-f et remplacer\".\n\n## Mama, la macro\nOn peut utiliser les `define` pour définir des fonctions que l'on pourra utiliser dans notre code.\n\n```c\n#define INC(a) a++ \n#define MULTI_LINE(a,b) a = b; \\\n                        b = 0; \n\n\nINC(my_variable); \nMULTI_LINE(my_variable, foobar) \n// Je souligne le fait qu'il peut ne pas y avoir de ';' en fin de ligne \n\n// Cela donnera  \nmy_variable++;\nmy_variable = foobar;\nfoobar = 0;\n```\n\n## If or not if\nNous pouvons déclarer des macros de manière conditionnelle. \nSi un nom est déjà défini alors on exécute le bout de code suivant. \n```c\n#ifdef DEBUG\n// Je souligne qu'il est rarement conseillé d'utiliser des printf() en debug\n// et que nous avons brisé la règle du nom des macros en MAJ.\n#define return printf(\"(%s:%d)\\n\", __FUNCTION__, __LINE__);  return\n#endif /* ! DEBUG */\n\nint main(void) {\n    return 1;\n}\n```\nDans ce cas, j'utilise un `#ifndef`, mais il existe aussi :\n- `#ifdef`\n- `#if`\n- `#else`\n- `#elif`\n```c\n#if (X == 1)\n#define Y 2\n#elif (X == 2)\n#define Y \"Ami de la bonne blague, bonjour !\"\n#else\n#define Y NULL\n#endif /* ! X */\n\n/* ... */\n\nint main(void) {\n    #if (X == 1)\n    printf(\"%d\\n\", Y);\n    #else \n    printf(\"%s\\n\", Y);\n    #endif /* ! X */\n}\n```\n\nOn aime bien signaler avec un commentaire en bloc la fin des `#if`. C'est une convention qui permet de mieux se repérer dans le code. \n\n## Macros prédéfinies\nVous avez pu voir dans l'exemple précédent que j'utilisais les mots-clés `__FUNCTION__` et `__LINE__`. \nComme vous pouvez vous en douter, ce sont des macros que le compilateur va remplacer par la bonne valeur.\n\nIl existe une liste de macros prédéfinies [Common Predifined](https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html).\n\nÀ noter qu'il existe des macros dites [System specific](https://gcc.gnu.org/onlinedocs/cpp/System-specific-Predefined-Macros.html).\n\nPetite liste non exhaustive : \n- `__DATE__` : Jan 14 2012\n- `__GNUC__` : Version majeure de GCC\n- `__TIME__` : 15:12:18\n- `__INCLUDE_LEVEL__` : La profondeur des includes en commençant par 0\n- `__BASE_FILE__` : Le nom du fichier actuel\n\n## Vers l'infini et au-delà des arguments\n```c\n// Ici, l'opérateur ## est l'opérateur de concaténation\n#define DEBUG_PRNTF(fmt, ...) printf(\"LOG\" ## fmt, __VA_ARGS__);\n```\nIci, on peut voir que l'on génère des macros variadiques, surtout utiles lors de la création de logs. \n(Même si ce n'est pas une bonne idée de faire des logs avec des `printf`.)\n\n## X-Macro\n\nPour cela, nous allons devoir créer un fichier externe, souvent nommé en `*.def` bien qu'il n'existe pas de convention.\n```c\n// color.def\nX(NC, \"\\e[0m\", \"No Color\", 0x000000) \nX(BLACK, \"\\e[0;30m\", \"Black\", 0x000000) \nX(GRAY, \"\\e[1;30m\", \"Gray\", 0x808080) \nX(RED, \"\\e[0;31m\", \"Red\", 0xFF0000) \nX(LIGHT_RED, \"\\e[1;31m\", \"Light Red\", 0xFF8080) \nX(GREEN, \"\\e[0;32m\", \"Green\", 0x00FF00) \nX(LIGHT_GREEN, \"\\e[1;32m\", \"Light Green\", 0x80FF80) \nX(BROWN, \"\\e[0;33m\", \"Brown\", 0xA52A2A) \nX(YELLOW, \"\\e[1;33m\", \"Yellow\", 0xFFFF00) \nX(BLUE, \"\\e[0;34m\", \"Blue\", 0x0000FF) \nX(LIGHT_BLUE, \"\\e[1;34m\", \"Light Blue\", 0xADD8E6) \nX(PURPLE, \"\\e[0;35m\", \"Purple\", 0x800080) \nX(LIGHT_PURPLE, \"\\e[1;35m\", \"Light Purple\", 0xEE82EE) \nX(CYAN, \"\\e[0;36m\", \"Cyan\", 0x00FFFF) \nX(LIGHT_CYAN, \"\\e[1;36m\", \"Light Cyan\", 0xE0FFFF) \nX(LIGHT_GRAY, \"\\e[0;37m\", \"Light Gray\", 0xD3D3D3) \nX(WHITE, \"\\e[1;37m\", \"White\", 0xFFFFFF)\n```\n\n```c\ntypedef struct {\n    const char *name;        \n    const char *ansi_code;  \n    const char *description;\n    unsigned int rgb;      \n} Color;\n\n#define X(NAME, ANSI, DESC, RGB) { #NAME, ANSI, DESC, RGB },\nColor colors[] = {\n    #include \"color.def\"\n};\n#undef X\n\n#define X(NAME, ANSI, DESC, RGB) printf(\"%s (%s) = %s\\n\", #NAME, DESC, #RGB);\nvoid print_colors() {\n    // Bien entendu, on pourrait itérer sur la structure créée mais c'est une illustration\n    #include \"color.def\"\n}\n#undef X\n```\nCe genre de macro est extrêmement utile. Je dois reconnaître qu'on la retrouve rarement dans un code source, mais elle permet de modifier le fonctionnement du programme sans pour autant devoir modifier le code source. Fun fact, elle est souvent utilisée dans la création de kernels. Elle permet de générer les structures globales comme l'IDT et la GDT.\n\n## Les problèmes \n__**Attention**__ : Petite mise au point d'abord, les macros sont des outils formidables mais il faut faire attention. Vous ne devez surtout pas utiliser ce genre de macro :\n```c\n#define MIN(a,b) (a < b ? a : b)\n```\n\nPrenons un exemple : `MIN(2 + 5, fibo(25))`\n### Problème n°1 \n`MIN(2 + 5, fibo(25))` => `(2 + 5 < fibo(25) ? 2 + 5 : fibo(25))`\n\nIci le problème est la priorité de calcul. Le compilateur va d'abord effectuer la comparaison puis l'addition, donc 2 + (1). On corrige cela par l'ajout de parenthèses en utilisant les arguments des macros.\n```c\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n```\nComme vous ne savez jamais ce que vos utilisateurs vont passer en paramètre, mettez toujours des parenthèses sur les arguments.\n### Problème n°2 \n`MIN(2 + 5, fibo(25))` => `(2 + 5 < fibo(25) ? 2 + 5 : fibo(25))`\n\nOn remarque que le compilateur fait un remplacement bête et méchant, ce qui veut dire que l'on va calculer deux fois `fibo(25)`. Je vous laisse imaginer si c'est une implémentation récursive.\n\nPour fixer ce problème, nous déclarons une variable intermédiaire avant le `if`. \n## Macros utiles\n\n```c\n#define MIN(a, b)                                                              \\\n    ({                                                                         \\\n        __typeof__(a) _a = a;                                                  \\\n        __typeof__(b) _b = b;                                                  \\\n        (_a) > (_b) ? (_b) : (_a);                                             \\\n    })\n\n#define ABS(a)                                                                 \\\n    ({                                                                         \\\n        __typeof__(a) _a = a;                                                  \\\n        0 < (_a) ? (_a) : -(_a);                                               \\\n    })\n\n#define MAX(a, b)                                                              \\\n    ({                                                                         \\\n        __typeof__(a) _a = a;                                                  \\\n        __typeof__(b) _b = b;                                                  \\\n        (_a) < (_b) ? (_b) : (_a);                                             \\\n    })\n\n#define CLAMP(a, x, b) MAX(a, MIN(x, b))\n// Pour les tableaux uniquement\n#define COUNT_OF(arr) sizeof(arr) / sizeof(arr[0])\n```\n\n## Là, on s'amuse\nIci, c'est du code purement overkill juste pour le fun. Je ne vous conseille pas forcément d'utiliser ces macros dans votre code.\nJe me fais juste plaisir (faut bien dans la vie).\n\n### Un auto free\n\n```c\n#define DEFER(free_call) __attribute__((cleanup(free_call)))\n\nvoid auto_free(void *ptr) {\n    void **p = (void **)ptr;\n    if (*p) {\n        free(*p);\n        *p = NULL;\n    }\n}\n\nint main() {\n  DEFER(auto_free) char* buffer = malloc(10);\n  return 0;\n}\n```\n\nJe vous laisse tester avec un petit `-fsanitize=address`. C'est vraiment une dinguerie. On pourrait même voir une amélioration de la fonction auto_free qui prend en paramètre une chaîne de caractères du nom de notre structure pour faire un switch.\n\n### Get time\n\nFonction plus chill où l'on calcule juste le temps d'exécution de notre fonction. Très utile pour faire du benchmark.\n\n```c\n#define MEASURE_TIME(block) {                                \\\n    clock_t start_time = clock();                            \\\n    block                                                    \\\n    clock_t end_time = clock();                              \\\n    double elapsed = ((double)(end_time - start_time)) / CLOCKS_PER_SEC * 1000.0; \\\n    printf(\"Execution time: %.3f ms\\n\", elapsed);            \\\n}\n```\n\n### Define Error\n\nPetite X-macro qui prend une macro en argument et qui l'expand.\n\n```c\n#define ERROR_LIST(X)          \\\n    X(ERROR_FILE_NOT_FOUND, \"File not found\")    \\\n    X(ERROR_INVALID_INPUT, \"Invalid input\")      \\\n    X(ERROR_OUT_OF_MEMORY, \"Out of memory\")      \\\n    X(ERROR_UNKNOWN, \"Unknown error\")\n\n#define DEFINE_ERROR_ENUM(code, message) code,\nenum ErrorCode {\n    ERROR_LIST(DEFINE_ERROR_ENUM)\n};\n\n#define DEFINE_ERROR_STRING(code, message) case code: return message;\nconst char* get_error_message(enum ErrorCode error_code) {\n    switch (error_code) {\n        ERROR_LIST(DEFINE_ERROR_STRING)\n        default: return \"Unrecognized error\";\n    }\n}\n\n/* ... */\nenum ErrorCode error = ERROR_OUT_OF_MEMORY;\nprintf(\"Error: %s\\n\", get_error_message(error));\n```\n\n### Génération de tests automatisés\n\nIci, on génère carrément des fonctions entières avec une macro, parce que le C n'a aucune limite. Moi aussi :eyes:\n```c\n#define GENERATE_TEST_FUNC(func, test_value, wanted_value) \\\n    void test_##func(void) { \\\n        printf(\"Test de \" #func \" avec valeur %d : \", test_value); \\\n        if (func(test_value)) { \\\n            printf(\"Succès\\n\"); \\\n        } else { \\\n            printf(\"Échec\\n\"); \\\n        } \\\n    }\n\n/* ... */\nGENERATE_TEST_FUNC(fibo, 10, 55);\n\ntest_fibo();\n```\n\n## RTFM\n\nIl est maintenant l'heure de conclure. Nous avons vu plein de choses très cool. Et si jamais vous êtes tentés, libre à vous de découvrir les macros par vous-même.\nDonc, conclusion : **RTFM**.\n\n> PS : Pour ce qui est du titre, les macros ne sont pas récursives, elles ne s'expandent qu'avec une profondeur de 1."},{"id":"plot-chart-docusaurus-mdx","metadata":{"permalink":"/plot-chart-docusaurus-mdx","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2024-08-01-test-graph.mdx","source":"@site/blog/2024-08-01-test-graph.mdx","title":"How to code plot and chart in Docusaurus with MDX","description":"Dans cet article, nous explorons comment ajouter des graphiques interactifs dans une page MDX avec Docusaurus.","date":"2024-08-01T00:00:00.000Z","tags":[{"inline":true,"label":"react","permalink":"/tags/react"},{"inline":true,"label":"mdx","permalink":"/tags/mdx"}],"readingTime":0.13333333333333333,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"plot-chart-docusaurus-mdx","title":"How to code plot and chart in Docusaurus with MDX","authors":["mrvym"],"unlisted":true,"tags":["react","mdx"]},"unlisted":false,"prevItem":{"title":"#define INC(a) INC(a+1)","permalink":"/define-inc-a-inc-a+1"},"nextItem":{"title":"Le Merveilleux Monde de Make","permalink":"/le-merveilleux-monde-de-make"}},"content":"Dans cet article, nous explorons comment ajouter des graphiques interactifs dans une page MDX avec **Docusaurus**.\n\n## Exemple de graphique interactif\n\nVoici un graphique interactif réalisé avec `@site/static` pour les données.\n\nimport BarChart from '../components/test';\n\n<BarChart />\n\n<!-- truncate -->"},{"id":"le-merveilleux-monde-de-make","metadata":{"permalink":"/le-merveilleux-monde-de-make","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/2024-03-14-Merveilleux-Monde-de-Make/index.md","source":"@site/blog/2024-03-14-Merveilleux-Monde-de-Make/index.md","title":"Le Merveilleux Monde de Make","description":"Les Makefiles constituent un outil essentiel dans le développement de logiciels que ce soit en C/C++ ou autre. Ils permettent une gestion efficace des projets en automatisant le processus de compilation, de nettoyage et de tests.","date":"2024-03-14T00:00:00.000Z","tags":[{"inline":true,"label":"make","permalink":"/tags/make"},{"inline":false,"label":"C Language","permalink":"/tags/c","description":"The most wonderful language"},{"inline":true,"label":"c++","permalink":"/tags/c"},{"inline":true,"label":"criterion","permalink":"/tags/criterion"}],"readingTime":7.14,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"le-merveilleux-monde-de-make","title":"Le Merveilleux Monde de Make","authors":["mrvym"],"tags":["make","C","c++","criterion"]},"unlisted":false,"prevItem":{"title":"How to code plot and chart in Docusaurus with MDX","permalink":"/plot-chart-docusaurus-mdx"},"nextItem":{"title":"IDEA / TODO / SUBJECT","permalink":"/todo"}},"content":"Les Makefiles constituent un outil essentiel dans le développement de logiciels que ce soit en C/C++ ou autre. Ils permettent une gestion efficace des projets en automatisant le processus de compilation, de nettoyage et de tests. \n\nDans cet article, nous explorerons les bonnes pratiques pour la création et l'utilisation de Makefiles dans des projets C quelque soit leurs complexités.\n\n<!-- truncate -->\n### Make, ca sert a quoi ?\n\nMake est un programme qui a pour but de générer des fichier. Il permet de générer des pdfs, des exécutables et bien plus.\n\n> Dans les années 1970, la compilation des programmes devient de plus en plus longue et complexe, nécessitant de nombreuses étapes interdépendantes. La plupart des systèmes alors utilisés reposent sur des script shell, nécessitant de répéter toutes les étapes lors de la moindre correction. C'est dans ce contexte que Make fut développé par le docteur Stuart Feldman en 1977. En gérant les dépendances entre fichiers sources et fichiers compilés, Make permet de ne compiler que ce qui est nécessaire à la suite de la modification d'un fichier source.\n\nIl existe un makefile par défaut, qui définit un grand nombre de règles afin de générer la plupart des fichiers avec lesquels, vous serez amené a travailler.\n\nPour voir ce makefile, par défaut : `make -p`\n\n### Hello World \n\nPour débuter, nous allons prendre un cas très simple celui d'un fichier source unique, dans le même dossier que notre makefile. \n\n```sh\n.\n└── main.c \n```\nDans ce cas, il existe 2 facons de faire.\n\n```sh\n$ make main # Je souligne l'absence du .c\n```\n\nDans cette commande, nous demandons a make de créer le fichier `main`. Mais comment sait-il qu'il doit utiliser le fichier main.c pour faire notre binaire ? Cela est défini dans les règles par défaut.\n\nNous pouvons aussi creer un fichier `Makefile`\n\n```makefile=\n# Makefile\nmy_compilation_rule: \n    gcc main.c\n```\n\nUne fois, le fichier crée, il suffit d'exécuter la commande `make` (qui, par défaut, exécute la première règle du fichier).\nNous pouvons aussi mettre en argument le nom de la règle que nous voulons exécuter `make my_compilation_rule`.\n\n### Plus on est de fou, plus on rit\n\nNotre projet grossit, nous avons maintenant un deuxième fichier source.\n```sh\n.\n├── foo.c\n├── foo.h\n└── main.c \n```\n\nDans l'objectif de faire un makefile propre, nous allons déclarer une variable OBJ qui contiendra nos différents fichiers. On en profite pour déclarer un variable CC pour notre compilateur.\n\n```makefile\n# makefile\nCC = gcc\nOBJ = main.o foo.o\n\n\n# Cette variable sera utilisée dans la règle implicite qui compile les .o  \nCFLAGS = # My C Flags for the compiler\nLDFLAGS = # My linker flags\nTARGET = a.out\n\nall: $(OBJ)\n\t$(CC) $(OBJ) -o $(TARGET) $(LDFLAGS)\n```\n\nCette fois-ci, nous avons ajouter des dépendances à notre règle `all`. Maintenant, make sait qu'il faut d'abord faire les fichiers .o avant de pouvoir faire le linkage de tous les fichiers en un binaire.\n\n```makefile\n# makefile\nSRC = $(wildcard *.c) # main.c foo.c\nOBJ = $(SRC:.c=.o) # main.o foo.o\n```\n\nDans ce makefile, nous avons choisi de ne pas récupérer, à la main, les différents fichiers source. Nous récupérons automatiquement les fichiers source via la fonction `wildcard`. Cette fonction agit comme le globbing d'un shell. Dans cette example, elle récupère tous les fichiers terminant par `.c`. \n\nNous les convertissons en `.o` via cette syntax `$(NAME:old=new)` qui n'est rien de moins qu'un replace. La suite de notre makefile reste néanmoins la même chose.\n\n### Clean\n\nComme vous avez pu le remarquer, un makefile peut facilement générer un grand nombre de fichiers. C'est pour cela que nous allons créer une nouvelle règle dans notre makefile qui a pour but de supprimer tous les fichiers issus de la compilation. \n\n```makefile\n\n# ...\n\nclean: \n    $(RM) $(OBJ)\n    $(RM) $(TARGET)\n```\n\nPour les petits curieux qui se demandent ce que signifie la variable RM. C'est un simple alias avec la commande `rm -f`. Il faut savoir que cette variable peut très bien override. On peut très bien voir `RM = echo` ou bien `RM = mv to/path/` (à la place du remove), cela peut être très utile dans certains projets.\n\n#### Phony\n\nNous l'avons dit au début de cet article, mais make est un utilitaire qui permet de générer des fichiers. Mais que se passe-t-il, si l'on appelle la règle clean et qui existe un fichier `clean` dans notre dossier. \n```sh\nmake: 'clean' is up to date.\n```\n\nPour éviter ce genre de problème, il faut spécifier dans notre makefile que notre règle n'a pas pour but de générer un fichier. Pour cela, nous utilisons le mot clé `phony`.\n\nIl suffit d'écrire. \n```makefile\n.PHONY: my_rule1 my_rule12 # ... \n```\n\n### On range le repo\nMaintenant, que nous avons réussi à faire un makefile propre, nous allons pouvoir faire évoluer notre projet en mettant nos fichiers dans un dossier `src`.\n\n```\n.\n├── Makefile\n└── src/\n    ├── foo.c\n    ├── foo.h\n    └── main.c\n```\n\nPour cela, il nous suffit de rechercher la liste de nos .c dans le dossier src/ puis de les transformer en .o. On peut modifier le code que nous avons fait ci-dessus.\n\n```makefile=\nSRCDIR = src\nSRC = $(wildcard $(SRCDIR)/*.c)\nOBJ = $(SRC:$(SRCDIR)/%.c=$(SRCDIR)/%.o)\n# qui est équivalent à\n# OBJ = src/main.o \\\n#       src/main.o\n\n```\n\n### Where GDB ?\nIl peut être utile d'avoir un règle debug, afin de ne pas avoir à mettre un `-g` dans nos CFLAGS par défaut.\n\nPour cela, il suffit de :\n```makefile\ndebug: CFLAGS += -g\ndebug: all\n```\nOn remarque que la règle debug n'a pas de corps. Elle se contente d'ajouter un flag et d'appeler notre règle `all`.\n\n### Tester, c'est tricher \n\nPour cet article, nous allons voir comment faire un Makefile pour une test suite criterion.\n```\n.\n├── Makefile\n├── src/\n...\n└── tests/\n    └── foo_test.c\n```\n\nPour pouvoir lancer, nos tests, il va falloir que l'on trouve les fichiers source du dossier `tests`, puis linker tous nos fichiers en excluant le fichier main.o.\n\n```makefile\nTEST_DIR = tests\nSRC_TEST = $(wildcard $(TEST_DIR)/*.c)\nOBJ_TEST = $(SRC:$(TEST_DIR)/%.c=$(TEST_DIR)/%.o)\n\n# ... \n\ncheck: $(filter-out $(SRC_DIR)/main.o, $(OBJ)) $(OBJ_TEST)\n$(CC) $^ -o $(TARGET) $(LDFLAGS)\n```\nOn remarque que le fichier main.o est exclus en utilisant la fonction `filter-out`. On voit aussi l'appel d'une variable pour le moment inconnu. Il en existe un grand nombre.\n\n- `$^`  : La liste des dépendances de la règle\n\n- `$<` : Le nom de la première dépendance\n\n- `$@` : Le nom de la règle\n\n\n### On teste les tests\n\nSi l'on parle de test, nous devons forcément parler de coverage. Pour cela rien de plus simple, nous ajoutons les flags a nos variables puis exécutons `GCOVR`\n\n```makefile=\ncoverage: CFLAGS += -fPIC --coverage\ncoverage: LDFLAGS += -lgcov -lcriterion\ncoverage: check\ngcovr --print-summary\n```\n\n### Like a pro\nLa création d'un dossier build est la cerise sur le gâteau. Elle permet au développeur de faire `rm -rf build/` pour faire un clean.\n\nPour cela, nous allons devoir modifier notre variable `OBJ` et nous allons devoir créer un règle pour la compilation des .o. Nous ne pouvons plus utiliser les règles implicite.\n\n```makefile\nBUILD_DIR = build\nOBJ = $(SRC:$(SRC_DIR)/%.c=$(BUILD_DIR)/%.o)\n\n# Compilation des fichiers source\n$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c | $(BUILD_DIR)\n$(CC) $(CFLAGS) -c $< -o $@\n    \n# Creer le repertoire de build\n$(BUILD_DIR):\nmkdir -p $(BUILD_DIR)\n```\nAlors on remarque que cette fois-ci, nous n'avons pas défini une règle, mais avec une variable. Nous avons même utilisé une sorte de regex pour la définir. \n\nNous avons aussi dû mettre un prérequis en plus, la règle $(build_dir). Le fait de mettre un `|` signifie qu'il doit d'abord vérifier qu'il est nécessaire de faire cette règle.\n\n## Bonus\n\n### Bibliothèque statique\nPour créer une bibliothèque statique à partir des fichiers source, vous pouvez ajouter des règles au Makefile :\n```makefile\nLIB_TARGET = libmylib.a\nLIB_OBJS = $(filter-out $(BUILD_DIR)/main.o, $(OBJS))\n\n$(LIB_TARGET): $(LIB_OBJS)\nar rcs $@ $^\n```\nUne fois, la librairie crée, vous pourrez simplement la link avec votre binaire.\n\n### Makefile récursif\nSi votre projet comporte des sous-modules, vous pouvez utiliser un Makefile récursif. Imaginons un projet avec la structure suivante.\n\n```sh\n.\n├── Makefile\n└── src/\n    ├── features1/\n        ...\n        └── Makefile\n    ├── features2/\n        ...\n        └── Makefile\n    ├── features3/\n        ...\n        └── Makefile\n    ├── features4/\n        ...\n        └── Makefile\n    ├── main.c\n    └── Makefile\n```\nPour cela, il y a deux approches possibles. La première serait de faire un seul makefile à la racine de notre projet et faire un find de nos fichiers .c. Nous verrons comment faire par la suite.\n\nLa deuxième, c'est de faire une structure récursif via le Makefile suivant. \n```makefile\n# src/makefile \nSUBDIRS = $(wildcard */.)\n\n.PHONY: subdirs $(SUBDIRS)\n\nsubdirs: $(SUBDIRS)\n\n$(SUBDIRS):\n    $(MAKE) -C $@\n```\n\nAvec ce fichier, nous allons pouvoir mettre un makefile dans chaque dossier features et lui et lui seul gérera la compilation de la features. Ils seront appelés par le `src/Makefile` via la règles subdirs.\n```makefile\n# Makefile\n\nexport CFLAGS = -Wall -Werror -pedantic\n\n# ...\n```\nN'oubliez pas d'export vos variables dans votre Makefile afin qu´elle s'applique sur les Makefiles suivants.\n\nCe genre d'architecture nécessite, la plupart du temps, de la combiner avec la création de librairie statique.\n### Répertoires infinis\n\nNous avons vu comment utiliser la fonction `wildcard` mais comment faire pour recuperer l'intégralité de nos fichiers sources ?\n\n```sh\n├── Makefile\n└── src/\n    └── foo/\n        └── bar/\n            ...\n                └── foobar/\n                    └── barfoo/\n                        └── here.c\n```\nLa prise en charge des répertoires \"infinis\" peut se faire via des règles génériques ou bien par l'intermédiaire d'un sub-shell.\n\nPar exemple :\n```makefile \n# Attention, il faut que votre systeme possede la command find\n\nSRC = $(shell find $(SRC_DIR) -name \"*.c\")\n```  \nou bien\n```makefile\n# Je laisse les plus aventureux d'entre vous dechiffrer ce code\n\nrwildcard = $(foreach d, $(wildcard $(1:=/*)), $(call rwildcard,$d,$2) $(filter $(subst *,%,$2),$d))\nSRC = $(rwildcard src,*.c)\n```\nou encore \n```makefile\nSRC = $(wildcard src/*.c) \\\n      $(wildcard src/*/*.c) \\\n      # ... # \n      $(wildcard src/*/*/*/*/*/*/*/*/*/*/.c)\n# S'il vous plait, ne faites pas ca \n```\n\n## $ make conclusion\n\nEn conclusion, l'utilisation judicieuse des Makefiles est cruciale pour la gestion efficace de projets. Il permet d'économiser énormément de temps lors du processus de développement. Ce n'est pas pour rien que la quasi-intégralité de l'industrie utilise cet outil. \n\nCette article n'étant bien entendu, pas exhaustif, je vous invite à vous renseigner par vous meme afin de découvrir les autres fonctionnalités de cet outil."},{"id":"todo","metadata":{"permalink":"/todo","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/1970-01-01-TODO.mdx","source":"@site/blog/1970-01-01-TODO.mdx","title":"IDEA / TODO / SUBJECT","description":"Pour les curieux, en recherche d'un sujet d'exploration","date":"1970-01-01T00:00:00.000Z","tags":[],"readingTime":1.8966666666666667,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"title":"IDEA / TODO / SUBJECT","authors":["mrvym"],"slug":"todo","date":"1970-01-01T00:00:00.000Z","unlisted":true},"unlisted":false,"prevItem":{"title":"Le Merveilleux Monde de Make","permalink":"/le-merveilleux-monde-de-make"},"nextItem":{"title":"Draft / Waiting","permalink":"/draft"}},"content":"import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nPour les curieux, en recherche d'un sujet d'exploration \n\n- [X] Fait\n- [ ] A faire \n\n<!-- truncate --> \n\nMon prompt ChatGPT :wink:\n<details>\nHello, I'm a French IT specialist. I want to improve my English, so I've created a blog about IT in English. You have two tasks:\n- Firstly, to list all the bad words, incorrect sentences and misspelled words. \nYou have to explain why and where the problem lies. You must explain this in French. If a sentence is correct, don't mention it.\n- For the second part, you need to critique the article. Any potential tips, topics... Anything that could improve the article. The critique must be in English.\nBe quick and precise, without unnecessary detail.\n</details>\n\n<Tabs>\n<TabItem value=\"hardware\" label=\"Hardware\">\n\n- [ ] I2C\n- [ ] SPI\n- [ ] UART\n- [X] Storage\n- [ ] Reverse engineering IOT\n- [ ] KICAD\n- [ ] STM32\n- [ ] InfintyBand\n\n</TabItem>\n<TabItem value=\"ToolChain\" label=\"ToolChain\">\n\n- [X] Make\n- [ ] Autotools \n- [ ] CMake\n- [ ] Compilation Chain (C or RUST)\n- [ ] Interpeter\n- [ ] JIT\n\n</TabItem>\n<TabItem value=\"Deploy\" label=\"Deploy\">\n\n- [X] CI\n- [ ] CD\n- [ ] Docker \n- [ ] Compose\n- [x] Terraform\n- [ ] Ansible\n- [ ] Amazon RM\n- [ ] Puppet \n- [ ] Valgrand\n- [ ] Salt\n\n</TabItem>\n<TabItem value=\"Linux\" label=\"Linux\">\n\n- [ ] Dual Boot\n- [ ] Arch Install\n- [ ] Nix install\n- [ ] Openstack\n- [ ] Kubernetes\n- [ ] K8s\n- [ ] K3s\n- [ ] Cube OS\n- [ ] BSD\n- [ ] Opensense vs Pfsense\n\n</TabItem>\n<TabItem value=\"Proxmox\" label=\"Proxmox\">\n\n- [X] IAC\n- [ ] Virtual Network + Namespace Linux\n- [ ] LXC\n- [ ] VM\n- [ ] FS (btrfs / ext4 / zfs)\n\n</TabItem>\n<TabItem value=\"Protocole\" label=\"Protocole\">\n\n- [ ] UDP / TCP\n- [ ] WebSocket\n- [ ] WebTransport\n- [ ] TLS\n- [ ] mTLS\n- [ ] Oauth2 \n- [ ] DNS vs DNSSEC\n\n</TabItem>\n</Tabs>\n\n<Tabs>\n<TabItem value=\"Vim\" label=\"Vim\">\n\n- [ ] Motion\n- [ ] Simple config\n- [ ] LSP\n- [ ] Simple syntax plugin\n\n</TabItem>\n<TabItem value=\"Utils\" label=\"Utils\">\n\n- [ ] openssl\n- [ ] cat / head / tail \n- [ ] modprobe\n- [ ] systemctl\n- [ ] netplan\n- [ ] systemd\n\n</TabItem>\n<TabItem value=\"IA\" label=\"IA\">\n\n- [ ] NLP\n- [ ] Computer Vision\n- [ ] Transformer\n- [ ] Reseau de neurones convolutif\n- [ ] Perceptron (Les bases de l'ia)\n\n</TabItem>\n<TabItem value=\"Son\" label=\"Son\">\n\n- [ ] Dba vs Dbc\n- [ ] Noice canceling\n- [ ] Court circuit acoustique\n- [ ] Pink noise vs white noise\n- [ ] Filter (LTH)\n- [ ] Enceinte passive vs active\n\n</TabItem>\n<TabItem value=\"Physics\" label=\"Physics\">\n\n- [ ] Pourquoi les planetes sont sur un meme plan ? \n    - Exemple du Velo\n- [ ] Comment un capteur photo sait que le rouge est du rouge ? \n\n</TabItem>\n<TabItem value=\"Rabbit Hole\" label=\"Rabbit Hole\">\n\n- [ ] OIDC\n- [ ] Blockchain\n- [ ] Web 3.0\n- [ ] Web 4.0 \n- [ ] NFT\n- [ ] Voice-as-User Interface (VUI)\n- [ ] Metaverse\n- [ ] Cloud computing (RoCEE)\n\n</TabItem>\n</Tabs>"},{"id":"draft","metadata":{"permalink":"/draft","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/draft.md","source":"@site/blog/draft.md","title":"Draft / Waiting","description":"Je travaille actuellement sur :","date":"1970-01-01T00:00:00.000Z","tags":[],"readingTime":0.20333333333333334,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"draft","title":"Draft / Waiting","authors":"mrvym","hide_title":false,"date":"1970-01-01T00:00:00.000Z","unlisted":true},"unlisted":false,"prevItem":{"title":"IDEA / TODO / SUBJECT","permalink":"/todo"},"nextItem":{"title":"Syscall on OpenBSD","permalink":"/syscall-on-openbsd"}},"content":"<!-- truncate -->\nJe travaille actuellement sur :\n- [ ] [How copy-paste works on Linux ?](/how-copy-paste-works-on-linux)\n- [ ] [How to code plot and chart in Docusaurus with MDX](/plot-chart-docusaurus-mdx)\n- [ ] [Syscall on OpenBSD](/syscall-on-openbsd)\n- [ ] [Sleep from Python to Electronics](/sleep-from-python-to-electronics)\n- [ ] [Protect a program to Pkill](/protect-a-programm-to-pkill)\n- [ ] [Comment marche le bus 1-Wire ?](/one-wire-protocol)"},{"id":"syscall-on-openbsd","metadata":{"permalink":"/syscall-on-openbsd","editUrl":"https://github.com/MrVyM/MrVyM.github.io/issues/blog/syscall.md","source":"@site/blog/syscall.md","title":"Syscall on OpenBSD","description":"Les versions récentes d'OpenBSD empêchent l'utilisation directe des syscalls depuis le code utilisateur, en imposant une vérification dans l'éditeur de liens dynamique (ld.so).","date":"1970-01-01T00:00:00.000Z","tags":[{"inline":true,"label":"openbsd","permalink":"/tags/openbsd"},{"inline":true,"label":"syscall","permalink":"/tags/syscall"},{"inline":true,"label":"kernel","permalink":"/tags/kernel"}],"readingTime":3.1,"hasTruncateMarker":true,"authors":[{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}],"frontMatter":{"slug":"syscall-on-openbsd","title":"Syscall on OpenBSD","tags":["openbsd","syscall","kernel"],"unlisted":true,"authors":"mrvym","hide_title":false,"date":"01/01/1970"},"unlisted":false,"prevItem":{"title":"Draft / Waiting","permalink":"/draft"}},"content":"Les versions récentes d'OpenBSD empêchent l'utilisation directe des syscalls depuis le code utilisateur, en imposant une vérification dans l'éditeur de liens dynamique (`ld.so`). \nCela renforce la sécurité en rendant les exploits plus difficiles. \nCe rapport explore la mise en place de cette protection, son fonctionnement, et comment la désactiver en modifiant le code source du système.\n\n<!-- truncate --> \n\n## Trouver le num d'un syscall \n\nAvant tout, nous devons faire un test en appelant un syscall. \nPour trouver le numéro de syscall de `void exit(int num)`, nous allons lire le man.\n```sh\n$ man 9 syscall\n```\nSection `Code references` on trouve /sys/kern/syscall.master\n\nCe fichier est très important, il contient la liste des syscalls sur OpenBSD. À noter qu'à la différence de Linux, leurs déclarations sont faites dans ce fichier donc dynamique. \nIl est relativement `simple` d'ajouter un syscall sur BSD. \n\n## Coder le syscall\n\n### En ASM\n```asm\n.global main\n.section .text\n\nmain:\n  movl $1, %eax;\n  syscall;\n  ret;\n```\n\n### En C \n\n```c\nint main(void) {\n  asm volatile (\"movl $1, %eax;\"\n                \"syscall;\");\n  return 0; // Unreached code \n}\n```\n\n## Result \nOn remarque assez vite que le binaire que nous avons compilé, ne fonctionne pas. \n`main[10291]: pinsyscalls addr 5a288eab978 code 1, pinoff 0xffffffff (pin 330 5a4c881d000-5a4c882b66d e66d) (libcpin 331 5a5145d0000-5a514687000 b7000) error 78\nAbort trap (core dumped)`\n\nJe suppose que cela doit venir d'un process interne au kernel, qui check la validité de notre appel et qui nous SIGABRT.\n\n## Comment fix le syscall ? \n\nL'idée est de trouver l'endroit qui check le linkage des syscalls dans le kernel et bypass le `if`.\n\nDans un premier temps, on cherche dans les `man` et non pas dans le code.\n5 min de lecture peuvent nous éviter beaucoup de recherche dans une codebase.\n\n```sh\n$ apropos syscall\npinsyscalls(2) - pin system call entry to precise locations in the address space\nsqlite3_vfs, sqlite3_syscall_ptr(3) - OS interface object\nktrace, ktrgenio, ktrnamei, KTRPOINT, ktrpsig, ktrsyscall, ktrsysret(9) - process tracing kernel interface\nsyscall(9) - system calls overview\n```\nNous avons déjà lu le syscall(9) pour trouver notre numéro de syscall, mais pas encore le premier pinsyscalls(2)\n\n### pinsyscalls(2)\n\nOn apprend que : \n- ld.so(1) cree des entry point pour chaque syscalls\n- si on ne respecte pas les entry point alors SIGABRT \n- Ca correspond a notre erreur\n\n### Trouver pinsyscall\n\nJ'en déduis que l'on cherche ou est `pinsyscall(1)`, trouver le code qui l'appelle puis le fix.\n\n```sh\n$ cd /usr/src\n# Un peu de recherche sur le mode clef syscall plus tard\n$ grep -r \"PINSYSCALL\"\n#  ...\nlib/libc/arch/amd64/SYS.h:\tPINSYSCALL(SYS_ ## x, 97b)\n```\n\nAlors la macro pinsyscall n'est pas défini dans ce fichier (qui est machine-depend). En regardant les include du header, on voit \n\n```c\n#include \"DEFS.h\" // Machine independent\n#include  // Machine // independent\n```\n\n### Trouver l'utilisation du pinsyscall\n\nJe découvre que la fonction `pinsyscall(1)` est défini dans mon fichier `DEFS.h`. C'est une macro qui génère de l'assembleur. \nJe ne me lance pas dans l'analyse de son code pour le moment, néanmoins, je garde en tête son existence. \nPour le moment, je cherche le code qui check le fonctionnement du `pinsyscall`. \n\nJ'ai vu que le include  existe, je vais aller voir par la.\n\n### sys/syscall.h\n\n```c\n$ find . -name \"syscall.h\"\n./libexec/ld.so/syscall.h\n./sys/arch/riscv64/include/syscall.h\n./sys/sys/syscall.h\n```\n\nDeux fichiers ont l'air intéressant celui de ld.so (cf le man que l'on a lu sur les pinsyscall).\n\n#### Le dossier libexec/ld.so\n\nAprès un rapide grep dans le directory du syscall.h pour trouver qui l'utilise. Je trouve le fichier `resolve.c`.\nCela me permet de découvrir l'implémentation de la fonction `pinsyscall` et de la struct.\n```c\n# /usr/src/libexec/ld.so/resolve.c : line 782\nstruct pinsyscalls {\nu_int offset;\nu_int sysno;\n}\n```\n#### Le dossier sys/sys\n\n```sh\ngrep -r \"syscall.h\"\nsyscall.h:/*\t$OpenBSD: syscall.h,v 1.282 2025/02/17 13:10:56 mpi Exp $\t*/\nsyscall_mi.h:#include \n```\n\n### The patch\n\nNous avons enfin trouvé le fichier qui contient le fameux `if` qui vérifie la condition d'appels des syscalls.\nIl nous suffit maintenant de supprimer le `else` pour ne jamais set le variable `error`.\n\n```diff\n$ diff syscall_mi.h.patch syscall_mi.h -Naur > syscall.patch\n--- syscall_mi.h\t2025-02-20 14:13:12.237060577 +0100\n+++ syscall_mi.h.patch\t2025-02-20 14:17:23.279746175 +0100\n@@ -94,8 +94,7 @@\n; /* multiple locations, hopefully a boring operation */\nelse\nerror = ENOSYS;\n-\t} else\n-\t\terror = ENOSYS;\n+\t}\nif (error == 0)\nreturn (0);\ndie:\n```"}],"blogListPaginated":[{"items":["protect-a-programm-to-pkill","sleep-from-python-to-electronics","one-wire-protocol","how-copy-paste-works-on-linux","le-plus-petit-segfault","tester-cest-tricher-compiler-c-est-douter","intro-terraform-proxmox","disque-dur-sas-sata-scsi-ide","define-inc-a-inc-a+1","plot-chart-docusaurus-mdx"],"metadata":{"permalink":"/","page":1,"postsPerPage":10,"totalPages":2,"totalCount":14,"nextPage":"/page/2","blogDescription":"Blog","blogTitle":"Blog"}},{"items":["le-merveilleux-monde-de-make","todo","draft","syscall-on-openbsd"],"metadata":{"permalink":"/page/2","page":2,"postsPerPage":10,"totalPages":2,"totalCount":14,"previousPage":"/","blogDescription":"Blog","blogTitle":"Blog"}}],"blogTags":{"/tags/hardware":{"inline":true,"label":"hardware","permalink":"/tags/hardware","items":["sleep-from-python-to-electronics","disque-dur-sas-sata-scsi-ide"],"pages":[{"items":["sleep-from-python-to-electronics","disque-dur-sas-sata-scsi-ide"],"metadata":{"permalink":"/tags/hardware","page":1,"postsPerPage":10,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/c":{"inline":false,"label":"C Language","permalink":"/tags/c","description":"The most wonderful language","items":["sleep-from-python-to-electronics","le-plus-petit-segfault","tester-cest-tricher-compiler-c-est-douter","define-inc-a-inc-a+1","le-merveilleux-monde-de-make"],"pages":[{"items":["sleep-from-python-to-electronics","le-plus-petit-segfault","tester-cest-tricher-compiler-c-est-douter","define-inc-a-inc-a+1","le-merveilleux-monde-de-make"],"metadata":{"permalink":"/tags/c","page":1,"postsPerPage":10,"totalPages":1,"totalCount":5,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/python":{"inline":true,"label":"Python","permalink":"/tags/python","items":["sleep-from-python-to-electronics"],"pages":[{"items":["sleep-from-python-to-electronics"],"metadata":{"permalink":"/tags/python","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/bus":{"inline":true,"label":"bus","permalink":"/tags/bus","items":["one-wire-protocol"],"pages":[{"items":["one-wire-protocol"],"metadata":{"permalink":"/tags/bus","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/1-wire":{"inline":true,"label":"1-wire","permalink":"/tags/1-wire","items":["one-wire-protocol"],"pages":[{"items":["one-wire-protocol"],"metadata":{"permalink":"/tags/1-wire","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/linux":{"inline":true,"label":"Linux","permalink":"/tags/linux","items":["how-copy-paste-works-on-linux"],"pages":[{"items":["how-copy-paste-works-on-linux"],"metadata":{"permalink":"/tags/linux","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/xorg":{"inline":true,"label":"Xorg","permalink":"/tags/xorg","items":["how-copy-paste-works-on-linux"],"pages":[{"items":["how-copy-paste-works-on-linux"],"metadata":{"permalink":"/tags/xorg","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/copy":{"inline":true,"label":"Copy","permalink":"/tags/copy","items":["how-copy-paste-works-on-linux"],"pages":[{"items":["how-copy-paste-works-on-linux"],"metadata":{"permalink":"/tags/copy","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/paste":{"inline":true,"label":"Paste","permalink":"/tags/paste","items":["how-copy-paste-works-on-linux"],"pages":[{"items":["how-copy-paste-works-on-linux"],"metadata":{"permalink":"/tags/paste","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/segv":{"inline":true,"label":"segv","permalink":"/tags/segv","items":["le-plus-petit-segfault"],"pages":[{"items":["le-plus-petit-segfault"],"metadata":{"permalink":"/tags/segv","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/git":{"inline":true,"label":"git","permalink":"/tags/git","items":["tester-cest-tricher-compiler-c-est-douter"],"pages":[{"items":["tester-cest-tricher-compiler-c-est-douter"],"metadata":{"permalink":"/tags/git","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/ci":{"inline":true,"label":"CI","permalink":"/tags/ci","items":["tester-cest-tricher-compiler-c-est-douter"],"pages":[{"items":["tester-cest-tricher-compiler-c-est-douter"],"metadata":{"permalink":"/tags/ci","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/terraform":{"inline":true,"label":"terraform","permalink":"/tags/terraform","items":["intro-terraform-proxmox"],"pages":[{"items":["intro-terraform-proxmox"],"metadata":{"permalink":"/tags/terraform","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/proxmox":{"inline":true,"label":"proxmox","permalink":"/tags/proxmox","items":["intro-terraform-proxmox"],"pages":[{"items":["intro-terraform-proxmox"],"metadata":{"permalink":"/tags/proxmox","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/devops":{"inline":false,"label":"devops","permalink":"/tags/devops","description":"DevOps - Tools","items":["intro-terraform-proxmox"],"pages":[{"items":["intro-terraform-proxmox"],"metadata":{"permalink":"/tags/devops","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/hcl":{"inline":true,"label":"hcl","permalink":"/tags/hcl","items":["intro-terraform-proxmox"],"pages":[{"items":["intro-terraform-proxmox"],"metadata":{"permalink":"/tags/hcl","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/bpg":{"inline":true,"label":"BPG","permalink":"/tags/bpg","items":["intro-terraform-proxmox"],"pages":[{"items":["intro-terraform-proxmox"],"metadata":{"permalink":"/tags/bpg","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/ssd":{"inline":true,"label":"SSD","permalink":"/tags/ssd","items":["disque-dur-sas-sata-scsi-ide"],"pages":[{"items":["disque-dur-sas-sata-scsi-ide"],"metadata":{"permalink":"/tags/ssd","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/sas":{"inline":true,"label":"SAS","permalink":"/tags/sas","items":["disque-dur-sas-sata-scsi-ide"],"pages":[{"items":["disque-dur-sas-sata-scsi-ide"],"metadata":{"permalink":"/tags/sas","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/storage":{"inline":true,"label":"Storage","permalink":"/tags/storage","items":["disque-dur-sas-sata-scsi-ide"],"pages":[{"items":["disque-dur-sas-sata-scsi-ide"],"metadata":{"permalink":"/tags/storage","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/define":{"inline":true,"label":"define","permalink":"/tags/define","items":["define-inc-a-inc-a+1"],"pages":[{"items":["define-inc-a-inc-a+1"],"metadata":{"permalink":"/tags/define","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/macro":{"inline":true,"label":"macro","permalink":"/tags/macro","items":["define-inc-a-inc-a+1"],"pages":[{"items":["define-inc-a-inc-a+1"],"metadata":{"permalink":"/tags/macro","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/react":{"inline":true,"label":"react","permalink":"/tags/react","items":["plot-chart-docusaurus-mdx"],"pages":[{"items":["plot-chart-docusaurus-mdx"],"metadata":{"permalink":"/tags/react","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/mdx":{"inline":true,"label":"mdx","permalink":"/tags/mdx","items":["plot-chart-docusaurus-mdx"],"pages":[{"items":["plot-chart-docusaurus-mdx"],"metadata":{"permalink":"/tags/mdx","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/make":{"inline":true,"label":"make","permalink":"/tags/make","items":["le-merveilleux-monde-de-make"],"pages":[{"items":["le-merveilleux-monde-de-make"],"metadata":{"permalink":"/tags/make","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/criterion":{"inline":true,"label":"criterion","permalink":"/tags/criterion","items":["le-merveilleux-monde-de-make"],"pages":[{"items":["le-merveilleux-monde-de-make"],"metadata":{"permalink":"/tags/criterion","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/openbsd":{"inline":true,"label":"openbsd","permalink":"/tags/openbsd","items":["syscall-on-openbsd"],"pages":[{"items":["syscall-on-openbsd"],"metadata":{"permalink":"/tags/openbsd","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/syscall":{"inline":true,"label":"syscall","permalink":"/tags/syscall","items":["syscall-on-openbsd"],"pages":[{"items":["syscall-on-openbsd"],"metadata":{"permalink":"/tags/syscall","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/tags/kernel":{"inline":true,"label":"kernel","permalink":"/tags/kernel","items":["syscall-on-openbsd"],"pages":[{"items":["syscall-on-openbsd"],"metadata":{"permalink":"/tags/kernel","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false}},"blogTagsListPath":"/tags","authorsMap":{"mrvym":{"name":"Vianney Marticou","title":"Mr.VyM @ EPITA","url":"https://github.com/mrvym","page":{"permalink":"/authors/mrvym"},"socials":{"github":"https://github.com/mrvym"},"imageURL":"https://github.com/mrvym.png","key":"mrvym"}}}},"docusaurus-plugin-content-pages":{"default":null},"docusaurus-plugin-debug":{},"docusaurus-plugin-svgr":{},"docusaurus-theme-classic":{},"docusaurus-bootstrap-plugin":{},"docusaurus-mdx-fallback-plugin":{}}}